<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>longest common subsequence on Pin Code Blog</title><link>https://zalman0813.github.io/tags/longest-common-subsequence/</link><description>Recent content in longest common subsequence on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 02 Apr 2023 20:46:36 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/longest-common-subsequence/index.xml" rel="self" type="application/rss+xml"/><item><title>115. Distinct Subsequences</title><link>https://zalman0813.github.io/posts/distinct-subsequences/</link><pubDate>Sun, 02 Apr 2023 20:46:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/distinct-subsequences/</guid><description>Link: https://leetcode.com/problems/distinct-subsequences/description/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(m×n) , where m is the length of str1 and n is the length of str2. # Space Complexity: O(m×n) class Solution: def numDistinct(self, str1: str, str2: str) -&amp;gt; int: m = len(str1) n = len(str2) dp = [[0 for x in range(0, n + 1)] for x in range(0, m + 1)] for i in range(0, n + 1): dp[m][i] = 0 for i in range(0, m + 1): dp[i][n] = 1 for i1 in range(m - 1, -1, -1): for i2 in range(n - 1, -1, -1): if str1[i1] == str2[i2]: dp[i1][i2] += dp[i1 + 1][i2 + 1] + dp[i1 + 1][i2] else: dp[i1][i2] = dp[i1 + 1][i2] return dp[0][0]</description></item><item><title>97. Interleaving String</title><link>https://zalman0813.github.io/posts/interleaving-string/</link><pubDate>Sun, 02 Apr 2023 20:40:23 +0800</pubDate><guid>https://zalman0813.github.io/posts/interleaving-string/</guid><description>Link: https://leetcode.com/problems/interleaving-string
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(s×t) where s and t are the lengths of s1 and s2, respectively # Space Complexity: O(s×t) where s and t are the lengths of s1 and s2, respectively class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -&amp;gt; bool: if len(s1) + len(s2) != len(s3): return False dp = [[False for i in range(len(s2) + 1)] for i in range(len(s1) + 1)] for s1_index in range(len(s1) + 1): for s2_index in range(len(s2) + 1): if s1_index == 0 and s2_index == 0: dp[s1_index][s2_index] = True elif s1_index == 0 and s2[s2_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] = dp[s1_index][s2_index - 1] elif s2_index == 0 and s1[s1_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] = dp[s1_index - 1][s2_index] else: if s1_index &amp;gt; 0 and s1[s1_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] = dp[s1_index - 1][s2_index] if s2_index &amp;gt; 0 and s2[s2_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] |= dp[s1_index][s2_index - 1] return dp[len(s1)][len(s2)]</description></item><item><title>300.Longest Increasing Subsequence</title><link>https://zalman0813.github.io/posts/longest-increasing-subsequence/</link><pubDate>Sun, 02 Apr 2023 20:09:25 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-increasing-subsequence/</guid><description>Link: https://leetcode.com/problems/longest-common-subsequence/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n^2) class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: size = len(nums) dp = [[0]*(size+1) for i in range(size+1)] for curr in range(size-1, -1, -1): for prev in range(curr-1, -2, -1): length = dp[curr+1][prev+1] if prev &amp;lt; 0 or nums[prev] &amp;lt; nums[curr]: length = max(length, 1+dp[curr+1][curr+1]) dp[curr][prev+1] = length return dp[0][0]</description></item><item><title>140. Word Break Ii</title><link>https://zalman0813.github.io/posts/word-break-ii/</link><pubDate>Sun, 02 Apr 2023 18:41:31 +0800</pubDate><guid>https://zalman0813.github.io/posts/word-break-ii/</guid><description>Link: https://leetcode.com/problems/word-break-ii/description/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n^2) class Solution: def wordBreak(self, s: str, word_dict: List[str]) -&amp;gt; List[str]: dp_solutions = [[]] * (len(s)+1) dp_solutions[0] = [&amp;#34;&amp;#34;] for i in range(1, len(s)+1): temp = [] for j in range(0, i): prefix = s[j:i] if prefix in word_dict: for substrings in dp_solutions[j]: temp.append((substrings + &amp;#34; &amp;#34; + prefix).strip()) dp_solutions[i] = temp return dp_solutions[len(s)]</description></item><item><title>1143. Longest Common Subsequence</title><link>https://zalman0813.github.io/posts/longest-common-subsequence/</link><pubDate>Sun, 02 Apr 2023 18:36:34 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-common-subsequence/</guid><description>Link: https://leetcode.com/problems/longest-common-subsequence/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&amp;gt; int: dp = [ [0 for j in range(len(text2)+1)] for i in range(len(text1)+1)] for i in range(1, len(text1)+1): for j in range(1, len(text2)+1): if text1[i-1] == text2[j-1]: dp[i][j] = 1 + dp[i-1][j-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]</description></item></channel></rss>