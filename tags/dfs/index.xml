<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dfs on Pin Code Blog</title><link>https://zalman0813.github.io/tags/dfs/</link><description>Recent content in dfs on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 16 Apr 2023 21:10:04 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml"/><item><title>114. Flatten Binary Tree to Linked List</title><link>https://zalman0813.github.io/posts/flatten-binary-tree-to-linked-list/</link><pubDate>Sun, 16 Apr 2023 21:10:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/flatten-binary-tree-to-linked-list/</guid><description>Link: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero
Solution: dfs
Code:
# Time Complexity: O(n). # Space Complexity: O(n). class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class Solution: head = None def flatten(self, root: Optional[TreeNode]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify root in-place instead. &amp;#34;&amp;#34;&amp;#34; def dfs(root): if root.right: dfs(root.right) if root.left: dfs(root.left) root.left, root.right, self.head = None, self.head, root if root: dfs(root) return root</description></item><item><title>1466. Reorder Routes to Make All Paths Lead to the City Zero</title><link>https://zalman0813.github.io/posts/reorder-routes-to-make-all-paths-lead-to-the-city-zero/</link><pubDate>Sun, 16 Apr 2023 18:40:15 +0800</pubDate><guid>https://zalman0813.github.io/posts/reorder-routes-to-make-all-paths-lead-to-the-city-zero/</guid><description>Link: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero
Solution: dfs
Code:
# Time Complexity: O(n). # Space Complexity: O(n). class Solution: def minReorder(self, n: int, connections: List[List[int]]) -&amp;gt; int: visited = set() edges = { (a, b) for a, b in connections } neighbor = { city: [] for city in range(n) } changes = 0 for a, b in connections: neighbor[a].append(b) neighbor[b].append(a) def dfs(city): nonlocal visited, edges, neighbor, changes for c in neighbor[city]: if c in visited: continue if (c, city) not in edges: changes += 1 visited.</description></item><item><title>417. Pacific Atlantic Water Flow</title><link>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</link><pubDate>Sun, 05 Feb 2023 23:33:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</guid><description>Link: https://leetcode.com/problems/pacific-atlantic-water-flow/
Solution: dfs
Code: dfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def pacificAtlantic(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: pac = set() atl = set() ROWS = len(heights) COLS = len(heights[0]) def dfs(r, c, visit, prevHeight): if ((r, c) in visit or r &amp;lt; 0 or c &amp;lt; 0 or r &amp;gt;= ROWS or c &amp;gt;= COLS or heights[r][c] &amp;lt; prevHeight ): return visit.add((r,c)) dfs(r + 1, c, visit, heights[r][c]) dfs(r - 1, c, visit, heights[r][c]) dfs(r, c + 1, visit, heights[r][c]) dfs(r, c - 1, visit, heights[r][c]) for c in range(COLS): dfs(0, c, pac, heights[0][c]) dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) for r in range(ROWS): dfs(r, 0, pac, heights[r][0]) dfs(r, COLS - 1, atl, heights[r][COLS-1]) res = [] for r in range(ROWS): for c in range(COLS): if (r, c) in pac and (r, c) in atl: res.</description></item><item><title>437. Path Sum Iii</title><link>https://zalman0813.github.io/posts/path-sum-iii/</link><pubDate>Sun, 15 Jan 2023 23:19:45 +0800</pubDate><guid>https://zalman0813.github.io/posts/path-sum-iii/</guid><description>Link: https://leetcode.com/problems/path-sum-iii/
Solution: DFS Code:
# Time Complexity: O(n) # Space Complexity: O(n) def count_paths(root, S): # TODO: Write your code here m = {} return count_paths_recursive(root, S, m, 0) def count_paths_recursive(curNode, S, cached, curPathSum): if not curNode: return 0 curPathSum += curNode.val path_count = 0 if curPathSum == S: path_count += 1 path_count += cached.get(curPathSum - S, 0) cached[curPathSum] = cached.get(curPathSum, 0) + 1 path_count += count_paths_recursive(curNode.left, S, cached, curPathSum) path_count += count_paths_recursive(curNode.</description></item><item><title>124. Binary Tree Maximum Path Sum</title><link>https://zalman0813.github.io/posts/binary-tree-maximum-path-sum/</link><pubDate>Sat, 14 Jan 2023 22:10:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-tree-maximum-path-sum/</guid><description>Link: https://leetcode.com/problems/binary-tree-maximum-path-sum
Solution: dfs Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxPathSum(self, root: Optional[TreeNode]) -&amp;gt; int: self.globalPathSum = -math.inf self.pathRecursive(root) return self.maxDiameter def pathRecursive(self, curNode): if not curNode: return 0 maxPathSumFromLeftNode = self.pathRecursive(curNode.left) maxPathSumFromRightNode = self.pathRecursive(curNode.right) # ignore paths with negative sums, since we need to find thhe maximum sum we should # ignore any path which has an overall negative sum.</description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://zalman0813.github.io/posts/maximum-depth-of-binary-tree/</link><pubDate>Thu, 08 Dec 2022 22:32:48 +0800</pubDate><guid>https://zalman0813.github.io/posts/maximum-depth-of-binary-tree/</guid><description>Link: https://leetcode.com/problems/maximum-depth-of-binary-tree
Status: done
Solution: dfs
Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: Optional[TreeNode]) -&amp;gt; int: return self.get_depth(root) def get_depth(self, root): if not root: return 0 left_depth = self.get_depth(root.left) right_depth = self.get_depth(root.right) return 1 + max(left_depth, right_depth)</description></item><item><title>543. Diameter of Binary Tree</title><link>https://zalman0813.github.io/posts/diameter-of-binary-tree/</link><pubDate>Wed, 07 Dec 2022 00:00:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/diameter-of-binary-tree/</guid><description>Link: https://leetcode.com/problems/diameter-of-binary-tre
Solution: dfs
Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&amp;gt; int: self.max_diameter = 0 self.getDiameter(root) return self.max_diameter def getDiameter(self, root): if not root: return 0 left_depth = self.getDiameter(root.left) right_depth = self.getDiameter(root.right) # get the diameter between two nodes diameter = left_depth + right_depth # get the maximum diameter self.</description></item><item><title>Balanced Binary Tree</title><link>https://zalman0813.github.io/posts/balanced-binary-tree/</link><pubDate>Mon, 14 Nov 2022 19:06:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/balanced-binary-tree/</guid><description>Solution: dfs
Code:
def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool: # use dfs to dive and conquer to find [balanced, height] for each child node. def dfs(root): if not root: return [True, 0] left, right = dfs(root.left), dfs(root.right) balanced = left[0] and right[0] and abs(left[1] - right[1]) &amp;lt;= 1 return [ balanced, 1 + max(left[1], right[1])] return dfs(root)[0] Time Complexity: O(n)
Space Complexity: O(n)</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</link><pubDate>Fri, 11 Nov 2022 23:20:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</guid><description>Link: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Status: done
Solution: binary search, dfs, recursive
Code:
binary search # Time Complexity: O(LogN) # Space Complexity: O(1) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: cur = root while cur: if cur.val &amp;gt; p.val and cur.val &amp;gt; q.val: cur = cur.left elif cur.val &amp;lt; p.val and cur.val &amp;lt; q.val: cur = cur.right else: return cur dfs - without binary search info - &amp;ldquo;236. Lowest Common Ancestor of a Binary Tree&amp;rdquo; # Time Complexity: O(LogN) # Space Complexity: O(LogN) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if root == p or root == q or not root: return root left = self.</description></item><item><title>733. Flood Fill</title><link>https://zalman0813.github.io/posts/flood-fill/</link><pubDate>Thu, 10 Nov 2022 20:42:59 +0800</pubDate><guid>https://zalman0813.github.io/posts/flood-fill/</guid><description>Link: https://leetcode.com/problems/flood-fill/
Solution: dfs
Code:
class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -&amp;gt; List[List[int]]: if image[sr][sc] == color: return image # keep original color to compare later orgColor = image[sr][sc] self.fill(image, sr, sc, orgColor, color) return image def fill(self, image, sr, sc, orgColor, color): # 1. skip if over matrix range # 2. skip if the color is not the same if ( sr &amp;lt; 0 or sc &amp;lt; 0 or sr &amp;gt;= len(image) or sc &amp;gt;= len(image[0]) or image[sr][sc] !</description></item><item><title>Invert Binary Tree</title><link>https://zalman0813.github.io/posts/invert-binary-tree/</link><pubDate>Mon, 07 Nov 2022 22:48:58 +0800</pubDate><guid>https://zalman0813.github.io/posts/invert-binary-tree/</guid><description>Link: https://leetcode.com/problems/invert-binary-tree/
Solution: dfs
Code:
class Solution: def invertTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root Time Complexity: O(n)
Space Complexity: O(n)</description></item></channel></rss>