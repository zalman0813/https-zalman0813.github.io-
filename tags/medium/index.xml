<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>medium on Pin Code Blog</title><link>https://zalman0813.github.io/tags/medium/</link><description>Recent content in medium on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 Feb 2023 17:05:57 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>528. Random Pick With Weight</title><link>https://zalman0813.github.io/posts/random-pick-with-weight/</link><pubDate>Sun, 19 Feb 2023 17:05:57 +0800</pubDate><guid>https://zalman0813.github.io/posts/random-pick-with-weight/</guid><description>Link: https://leetcode.com/problems/random-pick-with-weight/
Solution: binary search
# Time Complexity: # 1. Construct: O(n) # 2. pickIndex: o(logn) # Space Complexity: # 1. Construct: O(n) # 2. pickIndex: O(1) class Solution: def __init__(self, w: List[int]): self.cum_sums = [] cum = 0 for i in range(len(w)): cum += w[i] self.cum_sums.append(cum) def pickIndex(self) -&amp;gt; int: target = random.randint(1, self.cum_sums[-1]) # Assigning low pointer at the start of the array low = 0 # Assigning high pointer at the end of the array high = len(self.</description></item><item><title>658. Find K Closest Elements</title><link>https://zalman0813.github.io/posts/find-k-closest-elements/</link><pubDate>Sun, 19 Feb 2023 16:44:39 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-closest-elements/</guid><description>Link: https://leetcode.com/problems/find-k-closest-elements/description/
Solution: binary search
# Time Complexity: O(log(n-k)) # Space Complexity: O(1) class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&amp;gt; List[int]: l, r = 0, len(arr) - k while l &amp;lt; r: m = l + (r - l) // 2 if x - arr[m] &amp;gt; arr[m+k] - x: l = m + 1 else: r = m return arr[l:l+k]</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://zalman0813.github.io/posts/kth-largest-element-in-an-array/</link><pubDate>Mon, 13 Feb 2023 09:27:14 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-largest-element-in-an-array/</guid><description>Link: https://leetcode.com/problems/kth-largest-element-in-an-array/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(k) import heapq class Solution: def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int: # your code will replace this placeholder return statement minHeap = [] for i in range(len(nums)): if len(minHeap) == k: if minHeap[0] &amp;lt; nums[i]: heappop(minHeap) heappush(minHeap, nums[i]) else: heappush(minHeap, nums[i]) return minHeap[0]</description></item><item><title>347. Top K Frequent Elements</title><link>https://zalman0813.github.io/posts/top-k-frequent-elements/</link><pubDate>Sun, 12 Feb 2023 16:56:14 +0800</pubDate><guid>https://zalman0813.github.io/posts/top-k-frequent-elements/</guid><description>Link: https://leetcode.com/problems/top-k-frequent-elements/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(n+k) from collections import Counter import heapq class Solution: def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]: num_freq = Counter(nums) minHeap = [] for num, count in num_freq.items(): if len(minHeap) == k: if count &amp;gt; minHeap[0][0]: heapq.heappop(minHeap) heapq.heappush(minHeap, (count, num)) else: heapq.heappush(minHeap, (count, num)) return [ num for count, num in minHeap ]</description></item><item><title>973. K Closest Points to Origin</title><link>https://zalman0813.github.io/posts/k-closest-points-to-origin/</link><pubDate>Sun, 12 Feb 2023 16:14:53 +0800</pubDate><guid>https://zalman0813.github.io/posts/k-closest-points-to-origin/</guid><description>Link: https://leetcode.com/problems/k-closest-points-to-origin/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(k) import heapq class Solution: def kClosest(self, points: List[List[int]], K: int) -&amp;gt; List[List[int]]: maxHeap = [] for (x, y) in points: if len(maxHeap) == K: head_x = maxHeap[0][1][0] head_y = maxHeap[0][1][1] if self.distance(x, y) &amp;lt; self.distance(head_x, head_y): heapq.heappop(maxHeap) heapq.heappush(maxHeap, [-self.distance(x, y), (x, y)]) else: heapq.heappush(maxHeap, [-self.distance(x, y), (x, y)]) return [[point[0], point[1]] for dist, point in maxHeap] def distance(self, x, y): return (x*x + y*y)</description></item><item><title>767. Reorganize String</title><link>https://zalman0813.github.io/posts/reorganize-string/</link><pubDate>Sun, 12 Feb 2023 15:16:54 +0800</pubDate><guid>https://zalman0813.github.io/posts/reorganize-string/</guid><description>Link: https://leetcode.com/problems/reorganize-string/
Solution: top k elements
Code:
# Time Complexity: O(nlogc). Due to c bounded by the size of the alphabet, space is O(n). # Space Complexity: O(c). Due to c bounded by the size of the alphabet, space is O(1). from collections import Counter import heapq class Solution: def reorganizeString(self, s: str) -&amp;gt; str: char_counter = Counter(s) most_freq_chars = [] for char, freq in char_counter.items(): heapq.heappush(most_freq_chars, [-freq, char]) result = &amp;#34;&amp;#34; previous = None while len(most_freq_chars) &amp;gt; 0: count, char = heapq.</description></item><item><title>417. Pacific Atlantic Water Flow</title><link>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</link><pubDate>Sun, 05 Feb 2023 23:33:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</guid><description>Link: https://leetcode.com/problems/pacific-atlantic-water-flow/
Solution: dfs
Code: dfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def pacificAtlantic(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: pac = set() atl = set() ROWS = len(heights) COLS = len(heights[0]) def dfs(r, c, visit, prevHeight): if ((r, c) in visit or r &amp;lt; 0 or c &amp;lt; 0 or r &amp;gt;= ROWS or c &amp;gt;= COLS or heights[r][c] &amp;lt; prevHeight ): return visit.add((r,c)) dfs(r + 1, c, visit, heights[r][c]) dfs(r - 1, c, visit, heights[r][c]) dfs(r, c + 1, visit, heights[r][c]) dfs(r, c - 1, visit, heights[r][c]) for c in range(COLS): dfs(0, c, pac, heights[0][c]) dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) for r in range(ROWS): dfs(r, 0, pac, heights[r][0]) dfs(r, COLS - 1, atl, heights[r][COLS-1]) res = [] for r in range(ROWS): for c in range(COLS): if (r, c) in pac and (r, c) in atl: res.</description></item><item><title>1730. Shortest Path to Get Food</title><link>https://zalman0813.github.io/posts/shortest-path-to-get-food/</link><pubDate>Sun, 05 Feb 2023 23:28:13 +0800</pubDate><guid>https://zalman0813.github.io/posts/shortest-path-to-get-food/</guid><description>Link: https://leetcode.com/problems/shortest-path-to-get-food/
Solution: bfs
Code: bfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def getFood(self, grid): ROWS, COLS = len(grid), len(grid[0]) visit, queue = set(), collections.deque() for r in range(ROWS): for c in range(COLS): if grid[r][c] == &amp;#39;*&amp;#39;: queue.append((r,c, 0)) visit.add((r,c)) break directions = [(1,0),(0,-1), (-1,0), (0,1)] while queue: cur_r, cur_c, steps = queue.popleft() if grid[cur_r][cur_c] == &amp;#39;#&amp;#39;: return steps else: for dr,dc in directions: new_r, new_c = r + dr, c + dc if (0&amp;lt;=new_r&amp;lt;ROWS) and (0&amp;lt;=new_c&amp;lt;COLS) and grid[new_r][new_c] !</description></item><item><title>373. Find K Pairs With Smallest Sums</title><link>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</link><pubDate>Sun, 05 Feb 2023 21:28:17 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</guid><description>Link: https://leetcode.com/problems/find-k-pairs-with-smallest-sums
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(mlogm + klogm) -&amp;gt; (m + k)logm # Space Complexity: O(m), where m = min(k, n1) class Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&amp;gt; List[List[int]]: result = [] minHeap = [] # pop &amp;amp; push for i in range(min(k,len(nums1))): heappush(minHeap, (nums1[i]+nums2[0], i, 0)) counter = 1 while counter &amp;lt;= k and minHeap: _, i1, i2 = heappop(minHeap) result.</description></item><item><title>378. Kth Smallest Element in a Sorted Matrix</title><link>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</link><pubDate>Fri, 03 Feb 2023 22:34:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</guid><description>Link: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(nlogn+(klogn))=O((n+k)logn) # Space Complexity: O(n*n) class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -&amp;gt; int: # TODO: Write your code here minHeap = [] # firstly, insert (first elemetn of list, index of fist element, list) for l in matrix: heappush(minHeap, (l[0], 0, l)) for _ in range(k - 1): value, index, l = heappop(minHeap) index += 1 if index &amp;lt; len(l): heappush(minHeap, (l[index], index, l)) value, _, _ = heappop(minHeap) return value</description></item><item><title>199. Binary Tree Right Side View</title><link>https://zalman0813.github.io/posts/binary-tree-right-side-view/</link><pubDate>Sat, 14 Jan 2023 22:24:32 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-tree-right-side-view/</guid><description>Link: https://leetcode.com/problems/binary-tree-maximum-path-sum
Solution: dfs Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right from collections import deque class Solution: def rightSideView(self, root: Optional[TreeNode]) -&amp;gt; List[int]: if not root: return [] result = [] q = deque() q.append(root) while q: for i in range(len(q)): curNode = q.</description></item><item><title>457. Circular Array Loop</title><link>https://zalman0813.github.io/posts/circular-array-loop/</link><pubDate>Sun, 08 Jan 2023 17:27:02 +0800</pubDate><guid>https://zalman0813.github.io/posts/circular-array-loop/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: slow-fast Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def circularArrayLoop(self, arr: List[int]) -&amp;gt; bool: #remember all the numbers that have been visited visited = set() for i in range(len(arr)): if i in visited: continue is_forward = arr[i] &amp;gt;= 0 # if we are moving forward or not slow, fast = i, i # if slow or fast becomes &amp;#39;-1&amp;#39; this means we can&amp;#39;t find cycle for this number while True: # move one step for slow pointer slow = self.</description></item><item><title>61. Rotate List</title><link>https://zalman0813.github.io/posts/rotate-list/</link><pubDate>Sun, 08 Jan 2023 16:44:33 +0800</pubDate><guid>https://zalman0813.github.io/posts/rotate-list/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: linked-list
Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: if k &amp;lt;= 0 or not head: return head # find last node and length last_node = head list_length = 1 while last_node.next: last_node = last_node.</description></item><item><title>92. Reverse Linked List Ii</title><link>https://zalman0813.github.io/posts/reverse-linked-list-ii/</link><pubDate>Sun, 08 Jan 2023 14:29:47 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-linked-list-ii/</guid><description>Link: https://leetcode.com/problems/reverse-linked-list-ii
Solution: in-place reversal of a linkedlist
Code:
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]: if left == right: return head # after skipping &amp;#39;left-1&amp;#39; nodes, current will point to &amp;#39;left&amp;#39;th node prev, cur = None, head i = 0 while cur and i &amp;lt; left - 1: prev, cur = cur, cur.</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</link><pubDate>Fri, 11 Nov 2022 23:20:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</guid><description>Link: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Status: done
Solution: binary search, dfs, recursive
Code:
binary search # Time Complexity: O(LogN) # Space Complexity: O(1) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: cur = root while cur: if cur.val &amp;gt; p.val and cur.val &amp;gt; q.val: cur = cur.left elif cur.val &amp;lt; p.val and cur.val &amp;lt; q.val: cur = cur.right else: return cur dfs - without binary search info - &amp;ldquo;236. Lowest Common Ancestor of a Binary Tree&amp;rdquo; # Time Complexity: O(LogN) # Space Complexity: O(LogN) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if root == p or root == q or not root: return root left = self.</description></item></channel></rss>