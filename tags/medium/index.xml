<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>medium on Pin Code Blog</title><link>https://zalman0813.github.io/tags/medium/</link><description>Recent content in medium on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Feb 2023 23:33:04 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/medium/index.xml" rel="self" type="application/rss+xml"/><item><title>417. Pacific Atlantic Water Flow</title><link>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</link><pubDate>Sun, 05 Feb 2023 23:33:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</guid><description>Link: https://leetcode.com/problems/pacific-atlantic-water-flow/
Solution: dfs
Code: bfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def pacificAtlantic(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: pac = set() atl = set() ROWS = len(heights) COLS = len(heights[0]) def dfs(r, c, visit, prevHeight): if ((r, c) in visit or r &amp;lt; 0 or c &amp;lt; 0 or r &amp;gt;= ROWS or c &amp;gt;= COLS or heights[r][c] &amp;lt; prevHeight ): return visit.add((r,c)) dfs(r + 1, c, visit, heights[r][c]) dfs(r - 1, c, visit, heights[r][c]) dfs(r, c + 1, visit, heights[r][c]) dfs(r, c - 1, visit, heights[r][c]) for c in range(COLS): dfs(0, c, pac, heights[0][c]) dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) for r in range(ROWS): dfs(r, 0, pac, heights[r][0]) dfs(r, COLS - 1, atl, heights[r][COLS-1]) res = [] for r in range(ROWS): for c in range(COLS): if (r, c) in pac and (r, c) in atl: res.</description></item><item><title>1730. Shortest Path to Get Food</title><link>https://zalman0813.github.io/posts/shortest-path-to-get-food/</link><pubDate>Sun, 05 Feb 2023 23:28:13 +0800</pubDate><guid>https://zalman0813.github.io/posts/shortest-path-to-get-food/</guid><description>Link: https://leetcode.com/problems/shortest-path-to-get-food/
Solution: bfs
Code: bfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def getFood(self, grid): ROWS, COLS = len(grid), len(grid[0]) visit, queue = set(), collections.deque() for r in range(ROWS): for c in range(COLS): if grid[r][c] == &amp;#39;*&amp;#39;: queue.append((r,c, 0)) visit.add((r,c)) break directions = [(1,0),(0,-1), (-1,0), (0,1)] while queue: cur_r, cur_c, steps = queue.popleft() if grid[cur_r][cur_c] == &amp;#39;#&amp;#39;: return steps else: for dr,dc in directions: new_r, new_c = r + dr, c + dc if (0&amp;lt;=new_r&amp;lt;ROWS) and (0&amp;lt;=new_c&amp;lt;COLS) and grid[new_r][new_c] !</description></item><item><title>373. Find K Pairs With Smallest Sums</title><link>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</link><pubDate>Sun, 05 Feb 2023 21:28:17 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</guid><description>Link: https://leetcode.com/problems/find-k-pairs-with-smallest-sums
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(mlogm + klogm) -&amp;gt; (m + k)logm # Space Complexity: O(m), where m = min(k, n1) class Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&amp;gt; List[List[int]]: result = [] minHeap = [] # pop &amp;amp; push for i in range(min(k,len(nums1))): heappush(minHeap, (nums1[i]+nums2[0], i, 0)) counter = 1 while counter &amp;lt;= k and minHeap: _, i1, i2 = heappop(minHeap) result.</description></item><item><title>378. Kth Smallest Element in a Sorted Matrix</title><link>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</link><pubDate>Fri, 03 Feb 2023 22:34:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</guid><description>Link: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(nlogn+(klogn))=O((n+k)logn) # Space Complexity: O(n*n) class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -&amp;gt; int: # TODO: Write your code here minHeap = [] # firstly, insert (first elemetn of list, index of fist element, list) for l in matrix: heappush(minHeap, (l[0], 0, l)) for _ in range(k - 1): value, index, l = heappop(minHeap) index += 1 if index &amp;lt; len(l): heappush(minHeap, (l[index], index, l)) value, _, _ = heappop(minHeap) return value</description></item><item><title>199. Binary Tree Right Side View</title><link>https://zalman0813.github.io/posts/binary-tree-right-side-view/</link><pubDate>Sat, 14 Jan 2023 22:24:32 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-tree-right-side-view/</guid><description>Link: https://leetcode.com/problems/binary-tree-maximum-path-sum
Solution: dfs Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right from collections import deque class Solution: def rightSideView(self, root: Optional[TreeNode]) -&amp;gt; List[int]: if not root: return [] result = [] q = deque() q.append(root) while q: for i in range(len(q)): curNode = q.</description></item><item><title>457. Circular Array Loop</title><link>https://zalman0813.github.io/posts/circular-array-loop/</link><pubDate>Sun, 08 Jan 2023 17:27:02 +0800</pubDate><guid>https://zalman0813.github.io/posts/circular-array-loop/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: slow-fast Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def circularArrayLoop(self, arr: List[int]) -&amp;gt; bool: #remember all the numbers that have been visited visited = set() for i in range(len(arr)): if i in visited: continue is_forward = arr[i] &amp;gt;= 0 # if we are moving forward or not slow, fast = i, i # if slow or fast becomes &amp;#39;-1&amp;#39; this means we can&amp;#39;t find cycle for this number while True: # move one step for slow pointer slow = self.</description></item><item><title>61. Rotate List</title><link>https://zalman0813.github.io/posts/rotate-list/</link><pubDate>Sun, 08 Jan 2023 16:44:33 +0800</pubDate><guid>https://zalman0813.github.io/posts/rotate-list/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: linked-list
Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: if k &amp;lt;= 0 or not head: return head # find last node and length last_node = head list_length = 1 while last_node.next: last_node = last_node.</description></item><item><title>92. Reverse Linked List Ii</title><link>https://zalman0813.github.io/posts/reverse-linked-list-ii/</link><pubDate>Sun, 08 Jan 2023 14:29:47 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-linked-list-ii/</guid><description>Link: https://leetcode.com/problems/reverse-linked-list-ii
Solution: in-place reversal of a linkedlist
Code:
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]: if left == right: return head # after skipping &amp;#39;left-1&amp;#39; nodes, current will point to &amp;#39;left&amp;#39;th node prev, cur = None, head i = 0 while cur and i &amp;lt; left - 1: prev, cur = cur, cur.</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</link><pubDate>Fri, 11 Nov 2022 23:20:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</guid><description>Link: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Status: done
Solution: binary search, dfs, recursive
Code:
binary search # Time Complexity: O(LogN) # Space Complexity: O(1) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: cur = root while cur: if cur.val &amp;gt; p.val and cur.val &amp;gt; q.val: cur = cur.left elif cur.val &amp;lt; p.val and cur.val &amp;lt; q.val: cur = cur.right else: return cur dfs - without binary search info - &amp;ldquo;236. Lowest Common Ancestor of a Binary Tree&amp;rdquo; # Time Complexity: O(LogN) # Space Complexity: O(LogN) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if root == p or root == q or not root: return root left = self.</description></item></channel></rss>