<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>two heaps on Pin Code Blog</title><link>https://zalman0813.github.io/tags/two-heaps/</link><description>Recent content in two heaps on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 Jan 2023 13:12:57 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/two-heaps/index.xml" rel="self" type="application/rss+xml"/><item><title>436. Find Right Interval</title><link>https://zalman0813.github.io/posts/find-right-interval/</link><pubDate>Sun, 22 Jan 2023 13:12:57 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-right-interval/</guid><description>Link: https://leetcode.com/problems/find-right-interval/
Solution: two heaps
Code:
# Time Complexity: O(nlogn) # Space Complexity: O(n) class Solution: def findRightInterval(self, intervals: List[List[int]]) -&amp;gt; List[int]: n = len(intervals) # heaps for finding the maximum start and end maxStartHeap, maxEndHeap = [], [] result = [0 for x in range(n)] for endIndex in range(n): heappush(maxStartHeap, (-intervals[endIndex][0], endIndex)) heappush(maxEndHeap, (-intervals[endIndex][1], endIndex)) # go through all the intervals to find each interval&amp;#39;s next interval for _ in range(n): # let&amp;#39;s find the next interval of the interval which has the highest &amp;#39;end&amp;#39; topEnd, endIndex = heappop(maxEndHeap) result[endIndex] = -1 # defaults to - 1 if -maxStartHeap[0][0] &amp;gt;= -topEnd: topStart, startIndex = heappop(maxStartHeap) # find the the interval that has the closest &amp;#39;start&amp;#39; while maxStartHeap and -maxStartHeap[0][0] &amp;gt;= -topEnd: topStart, startIndex = heappop(maxStartHeap) result[endIndex] = startIndex # put the interval back as it could be the next interval of other intervals heappush(maxStartHeap, (topStart, startIndex)) return result</description></item><item><title>502. Ipo</title><link>https://zalman0813.github.io/posts/ipo/</link><pubDate>Sat, 21 Jan 2023 16:44:56 +0800</pubDate><guid>https://zalman0813.github.io/posts/ipo/</guid><description>Link: https://leetcode.com/problems/ipo/
Solution: two heaps
Code: two heaps
# Time Complexity: O(nlogn + klogn) , n is the total number of projects, k is the total number of projects we are selecting # Space Complexity: O(n) from heapq import * class Solution: def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -&amp;gt; int: minCapitalHeap = [] maxProfitHeap = [] # add all projects into minHeap, so that we can select a project with the smallest capital requirement.</description></item><item><title>295. Find Median From Data Stream</title><link>https://zalman0813.github.io/posts/find-median-from-data-stream/</link><pubDate>Sun, 15 Jan 2023 19:28:37 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-median-from-data-stream/</guid><description>Link: https://leetcode.com/problems/find-median-from-data-stream
Solution: two heaps Code:
# Time Complexity: # addNume: O(logn) # findMedian: O(1) # Space Complexity: O(n) from heapq import * class MedianFinder: def __init__(self): self.maxHeap = [] self.minHeap = [] def addNum(self, num: int) -&amp;gt; None if not self.maxHeap or -self.maxHeap[0] &amp;gt;= num: heappush(self.maxHeap, -num) else: heappush(self.minHeap, num) # more element than the min-heap # i.e. maxHeap [-5, -3, -1], minHeap [6, 7] if len(self.maxHeap) &amp;gt; len(self.minHeap) + 1: heappush(self.</description></item></channel></rss>