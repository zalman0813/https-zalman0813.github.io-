<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dp on Pin Code Blog</title><link>https://zalman0813.github.io/tags/dp/</link><description>Recent content in dp on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Mar 2023 09:19:39 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>198. House Robber</title><link>https://zalman0813.github.io/posts/house-robber/</link><pubDate>Sun, 26 Mar 2023 09:19:39 +0800</pubDate><guid>https://zalman0813.github.io/posts/house-robber/</guid><description>Link: https://leetcode.com/problems/house-robber/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def rob(self, nums: List[int]) -&amp;gt; int: rob1, rob2 = 0, 0 #[rob1, rob2, n, n+1, ...] for n in nums: temp = max(n + rob1, rob2) rob1 = rob2 rob2 = temp return rob2 # top-down by recursive, which will be timeout #Time Complexity: O(n) #Space Complexity: O(n) class Solution: def rob(self, nums: List[int]) -&amp;gt; int: dp = [0]*len(nums) def helper(i, nums, dp): if i &amp;gt;= len(nums): return 0 if dp[i] == 0: rob = helper(i+2, nums, dp) + nums[i] not_rob = helper(i+1, nums, dp) dp[i] = max(rob, not_rob) return dp[i] return helper(0, nums, dp)</description></item><item><title>1137. N Th Tribonacci Number</title><link>https://zalman0813.github.io/posts/n-th-tribonacci-number/</link><pubDate>Sun, 26 Mar 2023 08:29:59 +0800</pubDate><guid>https://zalman0813.github.io/posts/n-th-tribonacci-number/</guid><description>Link: https://leetcode.com/problems/n-th-tribonacci-number/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def tribonacci(self, n: int) -&amp;gt; int: if n == 0: return 0 if n &amp;lt;= 2: return 1 tn0 = 0 tn1 = 1 tn2 = 1 for i in range(3, n+1): tmp = tn0 + tn1 +tn2 tn0 = tn1 tn1 = tn2 tn2 = tmp return tmp</description></item><item><title>62. Unique Paths</title><link>https://zalman0813.github.io/posts/unique-paths/</link><pubDate>Sat, 25 Mar 2023 18:24:21 +0800</pubDate><guid>https://zalman0813.github.io/posts/unique-paths/</guid><description>Link: https://leetcode.com/problems/unique-paths/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(m*n) #Space Complexity: O(m) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: col = [1]*m for i in range(n-1): newCol = [1]*m for j in range(m - 2, -1, -1): newCol[j] = newCol[j+1] + col[j] col = newCol return col[0]</description></item><item><title>509. Fibonacci Number</title><link>https://zalman0813.github.io/posts/fibonacci-number/</link><pubDate>Sat, 25 Mar 2023 16:53:42 +0800</pubDate><guid>https://zalman0813.github.io/posts/fibonacci-number/</guid><description>Link: https://leetcode.com/problems/fibonacci-number
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(n) class Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0] = 0 dp[1] = 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] #Time Complexity: O(n) #Space Complexity: O(1) class Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 prev_2 = 0 prev_1 = 1 for i in range(2, n+1): tmp = prev_1 + prev_2 prev_2 = prev_1 prev_1 = tmp return prev_1</description></item><item><title>518. Coin Change Ii</title><link>https://zalman0813.github.io/posts/coin-change-ii/</link><pubDate>Sat, 25 Mar 2023 16:21:41 +0800</pubDate><guid>https://zalman0813.github.io/posts/coin-change-ii/</guid><description>Link: https://leetcode.com/problems/coin-change-ii/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*c), where c is amount #Space Complexity: O(n*c) class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: if amount == 0: return 1 dp = [[1 for j in range(len(coins))] for i in range(amount+1) ] for amt in range(1, amount+1): for j in range(len(coins)): x = 0 if amt - coins[j] &amp;gt;= 0: x = dp[amt - coins[j]][j] y = 0 if j &amp;gt;= 1: y = dp[amt][j-1] dp[amt][j] = x + y return dp[amount][len(coins)-1] #Time Complexity: O(n*c), where c is amount #Space Complexity: O(n) class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for amt in range(1, amount + 1): if amt &amp;gt;= coin: dp[amt] += dp[amt - coin] return dp[amount]</description></item><item><title>Partition a Set Into Two Subsets Such That the Difference of Subset Sums Is Minimum</title><link>https://zalman0813.github.io/posts/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</link><pubDate>Sun, 19 Mar 2023 22:11:16 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum_842494?leftPanelTab=0
Status: done
Solution: dp-top down
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) def minSubsetSumDifference(nums, n): # Write your code here. # Return the minimum difference in the form of an integer. dp = [[-1 for _ in range(sum(nums)+1)] for i in range(len(nums))] return rec(nums,0, 0, 0, dp) def rec(nums, i, sum1, sum2, dp): if i == len(nums): return abs(sum1 - sum2) if dp[i][sum1] == -1: dp[i][sum1] = min( rec( nums, i + 1, sum1 + nums[i], sum2, dp ), rec( nums, i + 1, sum1, sum2 + nums[i], dp ), ) return dp[i][sum1]</description></item><item><title>Number of Subsets</title><link>https://zalman0813.github.io/posts/number-of-subsets/</link><pubDate>Sun, 19 Mar 2023 20:00:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/number-of-subsets/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/number-of-subsets_3952532?source=youtube&amp;amp;campaign=striver_dp_videos&amp;amp;utm_source=youtube&amp;amp;utm_medium=affiliate&amp;amp;utm_campaign=striver_dp_videos
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) from os import * from sys import * from collections import * from math import * from typing import List def findWays(nums: List[int], target_sum: int) -&amp;gt; int: # Replace this placeholder return statement with your code tot = sum(nums) if tot &amp;lt; target_sum: return 0 dp = [ [0 for j in range(target_sum+1)] for i in range(len(nums))] # Base case 1 if nums[0] == 0: dp[0][0] = 2 # Base case 2 else: dp[0][0] = 1 if nums[0] &amp;lt;= target_sum: dp[0][nums[0]] = 1 for i in range(1, len(dp)): for required_sum in range(0, len(dp[0])): sum1 = 0 if nums[i] &amp;lt;= required_sum: sum1 = dp[i-1][required_sum - nums[i]] sum2 = dp[i-1][required_sum] dp[i][required_sum] = sum1 + sum2 return dp[len(nums)-1][target_sum]</description></item><item><title>871. Minimum Number of Refueling Stops</title><link>https://zalman0813.github.io/posts/minimum-number-of-refueling-stops/</link><pubDate>Sun, 19 Mar 2023 18:25:11 +0800</pubDate><guid>https://zalman0813.github.io/posts/minimum-number-of-refueling-stops/</guid><description>Link: https://leetcode.com/problems/minimum-number-of-refueling-stops/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n^2) #Space Complexity: O(n^2) class Solution: def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -&amp;gt; int: n = len(stations) dp = [ [0]*(n+1) for _ in range(n+1) ] i = 0 while i &amp;lt;= n: dp[i][0] = startFuel i += 1 i = 1 while i &amp;lt;= n: j = 1 while j &amp;lt;= i: if dp[i-1][j-1] &amp;gt;= stations[i-1][0]: dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + stations[i - 1][1]) else: dp[i][j] = dp[i-1][j] j += 1 i += 1 i = 0 while (i &amp;lt;= n): if dp[n][i] &amp;gt;= target: return i i += 1 return -1</description></item><item><title>1277. Count Square Submatrices With All Ones</title><link>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</link><pubDate>Sun, 19 Mar 2023 17:09:18 +0800</pubDate><guid>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</guid><description>Link: https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m) #Space Complexity: O(n*m) class Solution: def countSquares(self, nums: List[List[int]]) -&amp;gt; int: rows = len(nums) cols = len(nums[0]) dp = [ [0]*cols for i in range(rows) ] for i in range(rows): dp[i][0] = nums[i][0] for j in range(cols): dp[0][j] = nums[0][j] for i in range(1, rows): for j in range(1, cols): if nums[i][j] == 0: continue dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return sum([sum(row) for row in dp])</description></item><item><title>70. Climbing Stairs</title><link>https://zalman0813.github.io/posts/climbing-stairs/</link><pubDate>Sun, 12 Mar 2023 22:19:10 +0800</pubDate><guid>https://zalman0813.github.io/posts/climbing-stairs/</guid><description>Link: https://leetcode.com/problems/climbing-stairs/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: one = 1 two = 1 # n = 5 # [8,5,3,2,1,1] 4 times -&amp;gt; n - 1 for i in range(n - 1): tmp = one one = one + two two = tmp return one</description></item><item><title>1891. Cutting Ribbons</title><link>https://zalman0813.github.io/posts/cutting-ribbons/</link><pubDate>Sun, 12 Mar 2023 22:15:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/cutting-ribbons/</guid><description>Link: https://leetcode.com/problems/cutting-ribbons/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*k), where k is sizes.length #Space Complexity: O(n) def count_ribbon_pieces(n, sizes): # create the array to store the results dp = [-1]*(n+1) dp[0] = 0 # calculate the results for all combinations # and select the maximum for i in range(1, n+1): for c in sizes: if i-c &amp;gt;= 0 and dp[i-c] != -1: dp[i] = max(dp[i], 1 + dp[i-c]) if dp[n] !</description></item><item><title>416. Partition Equal Subset Sum</title><link>https://zalman0813.github.io/posts/partition-equal-subset-sum/</link><pubDate>Sun, 12 Mar 2023 21:58:49 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-equal-subset-sum/</guid><description>Link: https://leetcode.com/problems/partition-equal-subset-sum/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def canPartition(self, nums: List[int]) -&amp;gt; bool: if sum(nums) % 2 != 0: return False target = sum(nums) // 2 dp = set() dp.add(0) for i in range(len(nums)-1, -1, -1): nextDp = set() for t in dp: if t + nums[i] == target: return True nextDp.add(t+nums[i]) nextDp.add(t) dp = nextDp return False</description></item><item><title>494. Target Sum</title><link>https://zalman0813.github.io/posts/target-sum/</link><pubDate>Sun, 12 Mar 2023 21:45:23 +0800</pubDate><guid>https://zalman0813.github.io/posts/target-sum/</guid><description>Link: https://leetcode.com/problems/target-sum/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: tot = sum(nums) if tot &amp;lt; abs(target): return 0 dp = [ [0 for j in range(2*tot + 1)] for i in range(len(nums))] dp[0][tot + nums[0]] = 1 dp[0][tot - nums[0]] += 1 for i in range(1, len(dp)): for t in range(-tot, tot+1): if dp[i-1][tot + t] &amp;gt; 0: dp[i][tot + t - nums[i]] += dp[i-1][tot + t] dp[i][tot + t + nums[i]] += dp[i-1][tot + t] return dp[len(nums) - 1][target + tot]</description></item><item><title>70. Climing Stairs</title><link>https://zalman0813.github.io/posts/climing-stairs/</link><pubDate>Mon, 21 Nov 2022 22:14:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/climing-stairs/</guid><description>Solution: dp - top down
Code:
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: # DP: top-down # due to one step and two steps, # (n-2)th result depends on the result of n - 1, n # case n = 3, it&amp;#39;s two way here, # two step: 1 -&amp;gt; -&amp;gt; 3 # one step: 1 -&amp;gt; 2 # initiate one step, two step as 1.</description></item></channel></rss>