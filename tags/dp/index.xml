<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>dp on Pin Code Blog</title><link>https://zalman0813.github.io/tags/dp/</link><description>Recent content in dp on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 09 Apr 2023 18:02:21 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>131. Palindrome Partitioning</title><link>https://zalman0813.github.io/posts/palindrome-partitioning/</link><pubDate>Sun, 09 Apr 2023 18:02:21 +0800</pubDate><guid>https://zalman0813.github.io/posts/palindrome-partitioning/</guid><description>Link: https://leetcode.com/problems/palindromic-substrings/
Code:
# Time Complexity: O(2^n) # Space Complexity: O(2^n) class Solution: def partition(self, s: str) -&amp;gt; List[List[str]]: dp = [[] for _ in range(len(s) + 1)] dp[-1] = [[]] for i in range(len(s) - 1, -1, -1): for j in range(i + 1, len(s) + 1): if s[i:j] == s[i:j][::-1]: for item in dp[j]: dp[i].append([s[i:j]] + item) return dp[0]</description></item><item><title>72. Edit Distance</title><link>https://zalman0813.github.io/posts/edit-distance/</link><pubDate>Sun, 09 Apr 2023 17:46:33 +0800</pubDate><guid>https://zalman0813.github.io/posts/edit-distance/</guid><description>Link: https://leetcode.com/problems/edit-distance/description/
Code:
# Time Complexity: O(n^2), , where n is the length of the longest string. # Space Complexity: O(n^2) class Solution: def minDistance(self, str1: str, str2: str) -&amp;gt; int: dp = [[-1 for i in range(len(str2) + 1)] for j in range(len(str1)+1)] for i in range(len(str1)+1): dp[i][0] = i for j in range(len(str2)+1): dp[0][j] = j for i in range(1, len(str1)+1): for j in range(1, len(str2)+1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min( dp[i-1][j-1], # replace dp[i][j-1], # deletion dp[i-1][j] # insertion ) return dp[-1][-1]</description></item><item><title>647. Palindromic Substrings</title><link>https://zalman0813.github.io/posts/palindromic-substrings/</link><pubDate>Sun, 09 Apr 2023 16:57:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/palindromic-substrings/</guid><description>Link: https://leetcode.com/problems/palindromic-substrings/
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n^2) class Solution: def countSubstrings(self, str1: str) -&amp;gt; int: n = len(str1) lookup_table = [[False for _ in range(n)] for _ in range(n)] ps_count=0 for i in range(n - 1, -1, -1): for j in range(i, n): if str1[i] == str1[j]: if i+1 &amp;gt;= j: lookup_table[i][j] = True else: lookup_table[i][j] = lookup_table[i+1][j-1] if lookup_table[i][j]: ps_count += 1 return ps_count</description></item><item><title>516. Longest Palindromic Subsequence</title><link>https://zalman0813.github.io/posts/longest-palindromic-subsequence/</link><pubDate>Sun, 09 Apr 2023 16:52:54 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-palindromic-subsequence/</guid><description>Link: https://leetcode.com/problems/longest-palindromic-subsequence/description/
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n^2) class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: dp = [[0 for j in range(len(s))] for i in range(len(s))] for i in range(len(s)): dp[i][i] = 1 for i in range(len(s)-2, -1, -1): for j in range(i+1, len(s)): if j &amp;lt; i: continue if s[i] == s[j]: dp[i][j] = 2 + dp[i+1][j-1] else: dp[i][j] = max( dp[i+1][j], dp[i][j-1] ) return dp[0][len(s)-1]</description></item><item><title>5. Longest Palindromic Substring</title><link>https://zalman0813.github.io/posts/longest-palindromic-substring/</link><pubDate>Sun, 09 Apr 2023 16:41:07 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-palindromic-substring/</guid><description>Link: https://leetcode.com/problems/longest-palindromic-substring/
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n) class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: res = &amp;#34;&amp;#34; resLen = 0 for i in range(len(s)): # odd length l, r = i, i while l &amp;gt;= 0 and r &amp;lt; len(s) and s[l] == s[r]: if r - l + 1 &amp;gt; resLen: res = s[l:r+1] resLen = r - l + 1 l-=1 r+=1 # even length l, r = i, i+1 while l &amp;gt;= 0 and r &amp;lt; len(s) and s[l] == s[r]: if r - l + 1 &amp;gt; resLen: res = s[l:r+1] resLen = r - l + 1 l-=1 r+=1 return res</description></item><item><title>115. Distinct Subsequences</title><link>https://zalman0813.github.io/posts/distinct-subsequences/</link><pubDate>Sun, 02 Apr 2023 20:46:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/distinct-subsequences/</guid><description>Link: https://leetcode.com/problems/distinct-subsequences/description/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(m×n) , where m is the length of str1 and n is the length of str2. # Space Complexity: O(m×n) class Solution: def numDistinct(self, str1: str, str2: str) -&amp;gt; int: m = len(str1) n = len(str2) dp = [[0 for x in range(0, n + 1)] for x in range(0, m + 1)] for i in range(0, n + 1): dp[m][i] = 0 for i in range(0, m + 1): dp[i][n] = 1 for i1 in range(m - 1, -1, -1): for i2 in range(n - 1, -1, -1): if str1[i1] == str2[i2]: dp[i1][i2] += dp[i1 + 1][i2 + 1] + dp[i1 + 1][i2] else: dp[i1][i2] = dp[i1 + 1][i2] return dp[0][0]</description></item><item><title>97. Interleaving String</title><link>https://zalman0813.github.io/posts/interleaving-string/</link><pubDate>Sun, 02 Apr 2023 20:40:23 +0800</pubDate><guid>https://zalman0813.github.io/posts/interleaving-string/</guid><description>Link: https://leetcode.com/problems/interleaving-string
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(s×t) where s and t are the lengths of s1 and s2, respectively # Space Complexity: O(s×t) where s and t are the lengths of s1 and s2, respectively class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -&amp;gt; bool: if len(s1) + len(s2) != len(s3): return False dp = [[False for i in range(len(s2) + 1)] for i in range(len(s1) + 1)] for s1_index in range(len(s1) + 1): for s2_index in range(len(s2) + 1): if s1_index == 0 and s2_index == 0: dp[s1_index][s2_index] = True elif s1_index == 0 and s2[s2_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] = dp[s1_index][s2_index - 1] elif s2_index == 0 and s1[s1_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] = dp[s1_index - 1][s2_index] else: if s1_index &amp;gt; 0 and s1[s1_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] = dp[s1_index - 1][s2_index] if s2_index &amp;gt; 0 and s2[s2_index - 1] == s3[s1_index + s2_index - 1]: dp[s1_index][s2_index] |= dp[s1_index][s2_index - 1] return dp[len(s1)][len(s2)]</description></item><item><title>300.Longest Increasing Subsequence</title><link>https://zalman0813.github.io/posts/longest-increasing-subsequence/</link><pubDate>Sun, 02 Apr 2023 20:09:25 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-increasing-subsequence/</guid><description>Link: https://leetcode.com/problems/longest-common-subsequence/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n^2) class Solution: def lengthOfLIS(self, nums: List[int]) -&amp;gt; int: size = len(nums) dp = [[0]*(size+1) for i in range(size+1)] for curr in range(size-1, -1, -1): for prev in range(curr-1, -2, -1): length = dp[curr+1][prev+1] if prev &amp;lt; 0 or nums[prev] &amp;lt; nums[curr]: length = max(length, 1+dp[curr+1][curr+1]) dp[curr][prev+1] = length return dp[0][0]</description></item><item><title>140. Word Break Ii</title><link>https://zalman0813.github.io/posts/word-break-ii/</link><pubDate>Sun, 02 Apr 2023 18:41:31 +0800</pubDate><guid>https://zalman0813.github.io/posts/word-break-ii/</guid><description>Link: https://leetcode.com/problems/word-break-ii/description/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(n^2) # Space Complexity: O(n^2) class Solution: def wordBreak(self, s: str, word_dict: List[str]) -&amp;gt; List[str]: dp_solutions = [[]] * (len(s)+1) dp_solutions[0] = [&amp;#34;&amp;#34;] for i in range(1, len(s)+1): temp = [] for j in range(0, i): prefix = s[j:i] if prefix in word_dict: for substrings in dp_solutions[j]: temp.append((substrings + &amp;#34; &amp;#34; + prefix).strip()) dp_solutions[i] = temp return dp_solutions[len(s)]</description></item><item><title>1143. Longest Common Subsequence</title><link>https://zalman0813.github.io/posts/longest-common-subsequence/</link><pubDate>Sun, 02 Apr 2023 18:36:34 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-common-subsequence/</guid><description>Link: https://leetcode.com/problems/longest-common-subsequence/
Status: done
Solution: bottom-up
Code:
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def longestCommonSubsequence(self, text1: str, text2: str) -&amp;gt; int: dp = [ [0 for j in range(len(text2)+1)] for i in range(len(text1)+1)] for i in range(1, len(text1)+1): for j in range(1, len(text2)+1): if text1[i-1] == text2[j-1]: dp[i][j] = 1 + dp[i-1][j-1] else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[-1][-1]</description></item><item><title>198. House Robber</title><link>https://zalman0813.github.io/posts/house-robber/</link><pubDate>Sun, 26 Mar 2023 09:19:39 +0800</pubDate><guid>https://zalman0813.github.io/posts/house-robber/</guid><description>Link: https://leetcode.com/problems/house-robber/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def rob(self, nums: List[int]) -&amp;gt; int: rob1, rob2 = 0, 0 #[rob1, rob2, n, n+1, ...] for n in nums: temp = max(n + rob1, rob2) rob1 = rob2 rob2 = temp return rob2 # top-down by recursive, which will be timeout #Time Complexity: O(n) #Space Complexity: O(n) class Solution: def rob(self, nums: List[int]) -&amp;gt; int: dp = [0]*len(nums) def helper(i, nums, dp): if i &amp;gt;= len(nums): return 0 if dp[i] == 0: rob = helper(i+2, nums, dp) + nums[i] not_rob = helper(i+1, nums, dp) dp[i] = max(rob, not_rob) return dp[i] return helper(0, nums, dp)</description></item><item><title>1137. N Th Tribonacci Number</title><link>https://zalman0813.github.io/posts/n-th-tribonacci-number/</link><pubDate>Sun, 26 Mar 2023 08:29:59 +0800</pubDate><guid>https://zalman0813.github.io/posts/n-th-tribonacci-number/</guid><description>Link: https://leetcode.com/problems/n-th-tribonacci-number/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def tribonacci(self, n: int) -&amp;gt; int: if n == 0: return 0 if n &amp;lt;= 2: return 1 tn0 = 0 tn1 = 1 tn2 = 1 for i in range(3, n+1): tmp = tn0 + tn1 +tn2 tn0 = tn1 tn1 = tn2 tn2 = tmp return tmp</description></item><item><title>62. Unique Paths</title><link>https://zalman0813.github.io/posts/unique-paths/</link><pubDate>Sat, 25 Mar 2023 18:24:21 +0800</pubDate><guid>https://zalman0813.github.io/posts/unique-paths/</guid><description>Link: https://leetcode.com/problems/unique-paths/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(m*n) #Space Complexity: O(m) class Solution: def uniquePaths(self, m: int, n: int) -&amp;gt; int: col = [1]*m for i in range(n-1): newCol = [1]*m for j in range(m - 2, -1, -1): newCol[j] = newCol[j+1] + col[j] col = newCol return col[0]</description></item><item><title>509. Fibonacci Number</title><link>https://zalman0813.github.io/posts/fibonacci-number/</link><pubDate>Sat, 25 Mar 2023 16:53:42 +0800</pubDate><guid>https://zalman0813.github.io/posts/fibonacci-number/</guid><description>Link: https://leetcode.com/problems/fibonacci-number
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(n) class Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 dp = [0] * (n + 1) dp[0] = 0 dp[1] = 1 for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] #Time Complexity: O(n) #Space Complexity: O(1) class Solution: def fib(self, n: int) -&amp;gt; int: if n == 0: return 0 if n == 1: return 1 prev_2 = 0 prev_1 = 1 for i in range(2, n+1): tmp = prev_1 + prev_2 prev_2 = prev_1 prev_1 = tmp return prev_1</description></item><item><title>518. Coin Change Ii</title><link>https://zalman0813.github.io/posts/coin-change-ii/</link><pubDate>Sat, 25 Mar 2023 16:21:41 +0800</pubDate><guid>https://zalman0813.github.io/posts/coin-change-ii/</guid><description>Link: https://leetcode.com/problems/coin-change-ii/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*c), where c is amount #Space Complexity: O(n*c) class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: if amount == 0: return 1 dp = [[1 for j in range(len(coins))] for i in range(amount+1) ] for amt in range(1, amount+1): for j in range(len(coins)): x = 0 if amt - coins[j] &amp;gt;= 0: x = dp[amt - coins[j]][j] y = 0 if j &amp;gt;= 1: y = dp[amt][j-1] dp[amt][j] = x + y return dp[amount][len(coins)-1] #Time Complexity: O(n*c), where c is amount #Space Complexity: O(n) class Solution: def change(self, amount: int, coins: List[int]) -&amp;gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for amt in range(1, amount + 1): if amt &amp;gt;= coin: dp[amt] += dp[amt - coin] return dp[amount]</description></item><item><title>Partition a Set Into Two Subsets Such That the Difference of Subset Sums Is Minimum</title><link>https://zalman0813.github.io/posts/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</link><pubDate>Sun, 19 Mar 2023 22:11:16 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum_842494?leftPanelTab=0
Status: done
Solution: dp-top down
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) def minSubsetSumDifference(nums, n): # Write your code here. # Return the minimum difference in the form of an integer. dp = [[-1 for _ in range(sum(nums)+1)] for i in range(len(nums))] return rec(nums,0, 0, 0, dp) def rec(nums, i, sum1, sum2, dp): if i == len(nums): return abs(sum1 - sum2) if dp[i][sum1] == -1: dp[i][sum1] = min( rec( nums, i + 1, sum1 + nums[i], sum2, dp ), rec( nums, i + 1, sum1, sum2 + nums[i], dp ), ) return dp[i][sum1]</description></item><item><title>Number of Subsets</title><link>https://zalman0813.github.io/posts/number-of-subsets/</link><pubDate>Sun, 19 Mar 2023 20:00:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/number-of-subsets/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/number-of-subsets_3952532?source=youtube&amp;amp;campaign=striver_dp_videos&amp;amp;utm_source=youtube&amp;amp;utm_medium=affiliate&amp;amp;utm_campaign=striver_dp_videos
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) from os import * from sys import * from collections import * from math import * from typing import List def findWays(nums: List[int], target_sum: int) -&amp;gt; int: # Replace this placeholder return statement with your code tot = sum(nums) if tot &amp;lt; target_sum: return 0 dp = [ [0 for j in range(target_sum+1)] for i in range(len(nums))] # Base case 1 if nums[0] == 0: dp[0][0] = 2 # Base case 2 else: dp[0][0] = 1 if nums[0] &amp;lt;= target_sum: dp[0][nums[0]] = 1 for i in range(1, len(dp)): for required_sum in range(0, len(dp[0])): sum1 = 0 if nums[i] &amp;lt;= required_sum: sum1 = dp[i-1][required_sum - nums[i]] sum2 = dp[i-1][required_sum] dp[i][required_sum] = sum1 + sum2 return dp[len(nums)-1][target_sum]</description></item><item><title>871. Minimum Number of Refueling Stops</title><link>https://zalman0813.github.io/posts/minimum-number-of-refueling-stops/</link><pubDate>Sun, 19 Mar 2023 18:25:11 +0800</pubDate><guid>https://zalman0813.github.io/posts/minimum-number-of-refueling-stops/</guid><description>Link: https://leetcode.com/problems/minimum-number-of-refueling-stops/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n^2) #Space Complexity: O(n^2) class Solution: def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -&amp;gt; int: n = len(stations) dp = [ [0]*(n+1) for _ in range(n+1) ] i = 0 while i &amp;lt;= n: dp[i][0] = startFuel i += 1 i = 1 while i &amp;lt;= n: j = 1 while j &amp;lt;= i: if dp[i-1][j-1] &amp;gt;= stations[i-1][0]: dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + stations[i - 1][1]) else: dp[i][j] = dp[i-1][j] j += 1 i += 1 i = 0 while (i &amp;lt;= n): if dp[n][i] &amp;gt;= target: return i i += 1 return -1</description></item><item><title>1277. Count Square Submatrices With All Ones</title><link>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</link><pubDate>Sun, 19 Mar 2023 17:09:18 +0800</pubDate><guid>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</guid><description>Link: https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m) #Space Complexity: O(n*m) class Solution: def countSquares(self, nums: List[List[int]]) -&amp;gt; int: rows = len(nums) cols = len(nums[0]) dp = [ [0]*cols for i in range(rows) ] for i in range(rows): dp[i][0] = nums[i][0] for j in range(cols): dp[0][j] = nums[0][j] for i in range(1, rows): for j in range(1, cols): if nums[i][j] == 0: continue dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return sum([sum(row) for row in dp])</description></item><item><title>70. Climbing Stairs</title><link>https://zalman0813.github.io/posts/climbing-stairs/</link><pubDate>Sun, 12 Mar 2023 22:19:10 +0800</pubDate><guid>https://zalman0813.github.io/posts/climbing-stairs/</guid><description>Link: https://leetcode.com/problems/climbing-stairs/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: one = 1 two = 1 # n = 5 # [8,5,3,2,1,1] 4 times -&amp;gt; n - 1 for i in range(n - 1): tmp = one one = one + two two = tmp return one</description></item><item><title>1891. Cutting Ribbons</title><link>https://zalman0813.github.io/posts/cutting-ribbons/</link><pubDate>Sun, 12 Mar 2023 22:15:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/cutting-ribbons/</guid><description>Link: https://leetcode.com/problems/cutting-ribbons/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*k), where k is sizes.length #Space Complexity: O(n) def count_ribbon_pieces(n, sizes): # create the array to store the results dp = [-1]*(n+1) dp[0] = 0 # calculate the results for all combinations # and select the maximum for i in range(1, n+1): for c in sizes: if i-c &amp;gt;= 0 and dp[i-c] != -1: dp[i] = max(dp[i], 1 + dp[i-c]) if dp[n] !</description></item><item><title>416. Partition Equal Subset Sum</title><link>https://zalman0813.github.io/posts/partition-equal-subset-sum/</link><pubDate>Sun, 12 Mar 2023 21:58:49 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-equal-subset-sum/</guid><description>Link: https://leetcode.com/problems/partition-equal-subset-sum/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def canPartition(self, nums: List[int]) -&amp;gt; bool: if sum(nums) % 2 != 0: return False target = sum(nums) // 2 dp = set() dp.add(0) for i in range(len(nums)-1, -1, -1): nextDp = set() for t in dp: if t + nums[i] == target: return True nextDp.add(t+nums[i]) nextDp.add(t) dp = nextDp return False</description></item><item><title>494. Target Sum</title><link>https://zalman0813.github.io/posts/target-sum/</link><pubDate>Sun, 12 Mar 2023 21:45:23 +0800</pubDate><guid>https://zalman0813.github.io/posts/target-sum/</guid><description>Link: https://leetcode.com/problems/target-sum/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: tot = sum(nums) if tot &amp;lt; abs(target): return 0 dp = [ [0 for j in range(2*tot + 1)] for i in range(len(nums))] dp[0][tot + nums[0]] = 1 dp[0][tot - nums[0]] += 1 for i in range(1, len(dp)): for t in range(-tot, tot+1): if dp[i-1][tot + t] &amp;gt; 0: dp[i][tot + t - nums[i]] += dp[i-1][tot + t] dp[i][tot + t + nums[i]] += dp[i-1][tot + t] return dp[len(nums) - 1][target + tot]</description></item><item><title>70. Climing Stairs</title><link>https://zalman0813.github.io/posts/climing-stairs/</link><pubDate>Mon, 21 Nov 2022 22:14:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/climing-stairs/</guid><description>Solution: dp - top down
Code:
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: # DP: top-down # due to one step and two steps, # (n-2)th result depends on the result of n - 1, n # case n = 3, it&amp;#39;s two way here, # two step: 1 -&amp;gt; -&amp;gt; 3 # one step: 1 -&amp;gt; 2 # initiate one step, two step as 1.</description></item></channel></rss>