<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sliding windows on Pin Code Blog</title><link>https://zalman0813.github.io/tags/sliding-windows/</link><description>Recent content in sliding windows on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 Jan 2023 19:31:04 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/tags/sliding-windows/index.xml" rel="self" type="application/rss+xml"/><item><title>30. Substring With Concatenation of All Words</title><link>https://zalman0813.github.io/posts/substring-with-concatenation-of-all-words/</link><pubDate>Sun, 22 Jan 2023 19:31:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/substring-with-concatenation-of-all-words/</guid><description>Link: https://leetcode.com/problems/substring-with-concatenation-of-all-words
Solution: sliding windows
Code:
# O(n∗m∗len) where ‘n’ is the number of characters in the given string, ‘m’ is the total number of words, and ‘len’ is the length of a word. # Space Complexity: O(n+m) class Solution: def findSubstring(self, str1: str, words: List[str]) -&amp;gt; List[int]: result_indices = [] # TODO: Write your code here word_freq = Counter(words) word_count = len(words) word_length = len(words[0]) for i in range((len(str1) - word_count * word_length) + 1): word_seen = {} for j in range(word_count): next_word_index = i + j * word_length # if not equal to the word # Get the next word from the string word = str1[next_word_index: next_word_index + word_length] if word not in word_freq: # Break if we don&amp;#39;t need this word break word_seen[word] = 1 + word_seen.</description></item></channel></rss>