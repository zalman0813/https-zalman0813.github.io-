<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Pin Code Blog</title><link>https://zalman0813.github.io/posts/</link><description>Recent content in Posts on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 19 Mar 2023 22:11:16 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Partition a Set Into Two Subsets Such That the Difference of Subset Sums Is Minimum</title><link>https://zalman0813.github.io/posts/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</link><pubDate>Sun, 19 Mar 2023 22:11:16 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum_842494?leftPanelTab=0
Status: done
Solution: dp-top down
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) def minSubsetSumDifference(nums, n): # Write your code here. # Return the minimum difference in the form of an integer. dp = [[-1 for _ in range(sum(nums)+1)] for i in range(len(nums))] return rec(nums,0, 0, 0, dp) def rec(nums, i, sum1, sum2, dp): if i == len(nums): return abs(sum1 - sum2) if dp[i][sum1] == -1: dp[i][sum1] = min( rec( nums, i + 1, sum1 + nums[i], sum2, dp ), rec( nums, i + 1, sum1, sum2 + nums[i], dp ), ) return dp[i][sum1]</description></item><item><title>Number of Subsets</title><link>https://zalman0813.github.io/posts/number-of-subsets/</link><pubDate>Sun, 19 Mar 2023 20:00:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/number-of-subsets/</guid><description>Link: https://www.codingninjas.com/codestudio/problems/number-of-subsets_3952532?source=youtube&amp;amp;campaign=striver_dp_videos&amp;amp;utm_source=youtube&amp;amp;utm_medium=affiliate&amp;amp;utm_campaign=striver_dp_videos
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*s), where s is the target sum #Space Complexity: O(n*s) from os import * from sys import * from collections import * from math import * from typing import List def findWays(nums: List[int], target_sum: int) -&amp;gt; int: # Replace this placeholder return statement with your code tot = sum(nums) if tot &amp;lt; target_sum: return 0 dp = [ [0 for j in range(target_sum+1)] for i in range(len(nums))] # Base case 1 if nums[0] == 0: dp[0][0] = 2 # Base case 2 else: dp[0][0] = 1 if nums[0] &amp;lt;= target_sum: dp[0][nums[0]] = 1 for i in range(1, len(dp)): for required_sum in range(0, len(dp[0])): sum1 = 0 if nums[i] &amp;lt;= required_sum: sum1 = dp[i-1][required_sum - nums[i]] sum2 = dp[i-1][required_sum] dp[i][required_sum] = sum1 + sum2 return dp[len(nums)-1][target_sum]</description></item><item><title>2395. Find Subarrays With Equal Sum</title><link>https://zalman0813.github.io/posts/find-subarrays-with-equal-sum/</link><pubDate>Sun, 19 Mar 2023 19:45:47 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-subarrays-with-equal-sum/</guid><description># Time Complexity: O(n) # Space Complexity: O(k), numbers of sum class Solution: def findSubarrays(self, nums: List[int]) -&amp;gt; bool: sums = set() for i in range(len(nums)-1): t = nums[i]+nums[i+1] if t in sums: return True else: sums.add(t) return False</description></item><item><title>871. Minimum Number of Refueling Stops</title><link>https://zalman0813.github.io/posts/minimum-number-of-refueling-stops/</link><pubDate>Sun, 19 Mar 2023 18:25:11 +0800</pubDate><guid>https://zalman0813.github.io/posts/minimum-number-of-refueling-stops/</guid><description>Link: https://leetcode.com/problems/minimum-number-of-refueling-stops/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n^2) #Space Complexity: O(n^2) class Solution: def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -&amp;gt; int: n = len(stations) dp = [ [0]*(n+1) for _ in range(n+1) ] i = 0 while i &amp;lt;= n: dp[i][0] = startFuel i += 1 i = 1 while i &amp;lt;= n: j = 1 while j &amp;lt;= i: if dp[i-1][j-1] &amp;gt;= stations[i-1][0]: dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + stations[i - 1][1]) else: dp[i][j] = dp[i-1][j] j += 1 i += 1 i = 0 while (i &amp;lt;= n): if dp[n][i] &amp;gt;= target: return i i += 1 return -1</description></item><item><title>1277. Count Square Submatrices With All Ones</title><link>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</link><pubDate>Sun, 19 Mar 2023 17:09:18 +0800</pubDate><guid>https://zalman0813.github.io/posts/count-square-submatrices-with-all-ones/</guid><description>Link: https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m) #Space Complexity: O(n*m) class Solution: def countSquares(self, nums: List[List[int]]) -&amp;gt; int: rows = len(nums) cols = len(nums[0]) dp = [ [0]*cols for i in range(rows) ] for i in range(rows): dp[i][0] = nums[i][0] for j in range(cols): dp[0][j] = nums[0][j] for i in range(1, rows): for j in range(1, cols): if nums[i][j] == 0: continue dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return sum([sum(row) for row in dp])</description></item><item><title>70. Climbing Stairs</title><link>https://zalman0813.github.io/posts/climbing-stairs/</link><pubDate>Sun, 12 Mar 2023 22:19:10 +0800</pubDate><guid>https://zalman0813.github.io/posts/climbing-stairs/</guid><description>Link: https://leetcode.com/problems/climbing-stairs/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n) #Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: one = 1 two = 1 # n = 5 # [8,5,3,2,1,1] 4 times -&amp;gt; n - 1 for i in range(n - 1): tmp = one one = one + two two = tmp return one</description></item><item><title>2427. Number of Common Factors</title><link>https://zalman0813.github.io/posts/number-of-common-factors/</link><pubDate>Sun, 12 Mar 2023 22:18:47 +0800</pubDate><guid>https://zalman0813.github.io/posts/number-of-common-factors/</guid><description>Link: https://leetcode.com/problems/number-of-common-factors/description/
Status: done
Solution: math
Code:
#Time Complexity: O(n), where n is the smaller one in a, b #Space Complexity: O(1) class Solution: def commonFactors(self, a: int, b: int) -&amp;gt; int: if b &amp;gt; a: a, b = b, a count = 0 for i in range(1, b+1): if a % i == 0 and b % i == 0: count += 1 return count</description></item><item><title>1891. Cutting Ribbons</title><link>https://zalman0813.github.io/posts/cutting-ribbons/</link><pubDate>Sun, 12 Mar 2023 22:15:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/cutting-ribbons/</guid><description>Link: https://leetcode.com/problems/cutting-ribbons/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*k), where k is sizes.length #Space Complexity: O(n) def count_ribbon_pieces(n, sizes): # create the array to store the results dp = [-1]*(n+1) dp[0] = 0 # calculate the results for all combinations # and select the maximum for i in range(1, n+1): for c in sizes: if i-c &amp;gt;= 0 and dp[i-c] != -1: dp[i] = max(dp[i], 1 + dp[i-c]) if dp[n] !</description></item><item><title>416. Partition Equal Subset Sum</title><link>https://zalman0813.github.io/posts/partition-equal-subset-sum/</link><pubDate>Sun, 12 Mar 2023 21:58:49 +0800</pubDate><guid>https://zalman0813.github.io/posts/partition-equal-subset-sum/</guid><description>Link: https://leetcode.com/problems/partition-equal-subset-sum/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def canPartition(self, nums: List[int]) -&amp;gt; bool: if sum(nums) % 2 != 0: return False target = sum(nums) // 2 dp = set() dp.add(0) for i in range(len(nums)-1, -1, -1): nextDp = set() for t in dp: if t + nums[i] == target: return True nextDp.add(t+nums[i]) nextDp.add(t) dp = nextDp return False</description></item><item><title>494. Target Sum</title><link>https://zalman0813.github.io/posts/target-sum/</link><pubDate>Sun, 12 Mar 2023 21:45:23 +0800</pubDate><guid>https://zalman0813.github.io/posts/target-sum/</guid><description>Link: https://leetcode.com/problems/target-sum/description/
Status: done
Solution: dp-bottom up
Code:
#Time Complexity: O(n*m), where m = sum(nums) #Space Complexity: O(n) class Solution: def findTargetSumWays(self, nums: List[int], target: int) -&amp;gt; int: tot = sum(nums) if tot &amp;lt; abs(target): return 0 dp = [ [0 for j in range(2*tot + 1)] for i in range(len(nums))] dp[0][tot + nums[0]] = 1 dp[0][tot - nums[0]] += 1 for i in range(1, len(dp)): for t in range(-tot, tot+1): if dp[i-1][tot + t] &amp;gt; 0: dp[i][tot + t - nums[i]] += dp[i-1][tot + t] dp[i][tot + t + nums[i]] += dp[i-1][tot + t] return dp[len(nums) - 1][target + tot]</description></item><item><title>473. Matchsticks to Square</title><link>https://zalman0813.github.io/posts/matchsticks-to-square/</link><pubDate>Sun, 05 Mar 2023 23:26:52 +0800</pubDate><guid>https://zalman0813.github.io/posts/matchsticks-to-square/</guid><description>Link: https://leetcode.com/problems/matchsticks-to-square
Status: done
Solution: backtracking
Code:
#Time Complexity: O(4^n) #Space Complexity: O(n) class Solution: def makesquare(self, matchsticks: List[int]) -&amp;gt; bool: tot_length = sum(matchsticks) if tot_length % 4 != 0: return False length = tot_length / 4 sides = [0]*4 matchsticks.sort(reverse=True) def backtracking(i): if i == len(matchsticks): return True for j in range(4): if sides[j] + matchsticks[i] &amp;lt;= length: sides[j] += matchsticks[i] if backtracking(i+1): return True sides[j] -= matchsticks[i] return False return backtracking(0)</description></item><item><title>337. House Robber Iii</title><link>https://zalman0813.github.io/posts/house-robber-iii/</link><pubDate>Sun, 05 Mar 2023 08:20:19 +0800</pubDate><guid>https://zalman0813.github.io/posts/house-robber-iii/</guid><description>Link: https://leetcode.com/problems/house-robber-iii/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(n) #Space Complexity: O(h), , where h is the height of the tree # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def dfs(self, root): if root is None: return [0, 0] leftChild = self.dfs(root.left) rightChild = self.dfs(root.right) not_node = max(leftChild) + max(rightChild) node = root.</description></item><item><title>93. Restore Ip Addresses</title><link>https://zalman0813.github.io/posts/restore-ip-addresses/</link><pubDate>Sun, 05 Mar 2023 08:16:16 +0800</pubDate><guid>https://zalman0813.github.io/posts/restore-ip-addresses/</guid><description>Link: https://leetcode.com/problems/restore-ip-addresses/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(1) #Space Complexity: O(1) class Solution: def restoreIpAddresses(self, s: str) -&amp;gt; List[str]: if len(s) &amp;lt; 4 or len(s) &amp;gt; 12: return [] result = [] def backtracking(i, dots, curIp): if dots == 4 and i == len(s): result.append(curIp[:-1]) return if dots &amp;gt; 4: return for j in range(i, min(i+3,len(s))): if int(s[i:j+1]) &amp;lt;= 255 and (i == j or s[i] != &amp;#39;0&amp;#39;): backtracking(j+1, dots + 1, curIp + s[i:j+1] + &amp;#34;.</description></item><item><title>79. Word Search</title><link>https://zalman0813.github.io/posts/word-search/</link><pubDate>Sun, 05 Mar 2023 08:06:48 +0800</pubDate><guid>https://zalman0813.github.io/posts/word-search/</guid><description>Link: https://leetcode.com/problems/word-search/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(n×3^l) #Space Complexity: O(l), , where l is the length of the word to be searched in the grid. class Solution: def word_search(self, grid, word): n = len(grid) if n &amp;lt; 1: return False m = len(grid[0]) if m &amp;lt; 1: return False for row in range(n): for col in range(m): if self.depth_first_search(row, col, grid, word): return True return False def depth_first_search(self,row, col, grid, word): if len(word) == 0: return True if row &amp;lt; 0 or row == len(grid) or col &amp;lt; 0 or col == len(grid[0]) \ or word[0].</description></item><item><title>51. N Queens</title><link>https://zalman0813.github.io/posts/n-queens/</link><pubDate>Sun, 05 Mar 2023 08:04:05 +0800</pubDate><guid>https://zalman0813.github.io/posts/n-queens/</guid><description>Link: https://leetcode.com/problems/n-queens/
Status: done
Solution: backtracking
Code:
#Time Complexity: O(n^2) #Space Complexity: O(n) class Solution: def mapping(self, n, i): pattern = [&amp;#34;.&amp;#34;]*n pattern[i] = &amp;#39;Q&amp;#39; return &amp;#34;&amp;#34;.join(pattern) def is_valid_move(self, proposed_row, proposed_col, solution): for i in range(proposed_row): old_row = i old_col = solution[i] diagonal_offset = proposed_row - old_row if (proposed_col == old_col or proposed_col + diagonal_offset == old_col or proposed_col - diagonal_offset == old_col): return False return True def backtracking(self, n, row, solution, results): if row == n: results.</description></item><item><title>55. Jump Game I</title><link>https://zalman0813.github.io/posts/jump-game-i/</link><pubDate>Sun, 26 Feb 2023 22:00:30 +0800</pubDate><guid>https://zalman0813.github.io/posts/jump-game-i/</guid><description>Link: https://leetcode.com/problems/jump-game/
Solution: greedy
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: end = len(nums) - 1 for i in range(len(nums) - 2, -1, -1): if i + nums[i] &amp;gt;= end: end = i if end == 0: return True return False</description></item><item><title>881. Boats to Save People</title><link>https://zalman0813.github.io/posts/boats-to-save-people/</link><pubDate>Sun, 26 Feb 2023 22:00:13 +0800</pubDate><guid>https://zalman0813.github.io/posts/boats-to-save-people/</guid><description>Link: https://leetcode.com/problems/boats-to-save-people/description/
Solution: greedy
# Time Complexity: O(nlogn) # Space Complexity: O(n), n represents the memory required to sort this array. class Solution: def numRescueBoats(self, people: List[int], limit: int) -&amp;gt; int: people.sort() l = 0 r = len(people) - 1 boats = 0 while l &amp;lt;= r: if people[l] + people[r] &amp;lt;= limit: l += 1 r -= 1 boats += 1 return boats</description></item><item><title>134. Gas Station</title><link>https://zalman0813.github.io/posts/gas-station/</link><pubDate>Sun, 26 Feb 2023 21:59:51 +0800</pubDate><guid>https://zalman0813.github.io/posts/gas-station/</guid><description>Link: https://leetcode.com/problems/gas-station/
Solution: greedy
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -&amp;gt; int: if sum(gas) &amp;lt; sum(cost): return -1 start = 0 total = 0 for i in range(len(gas)): total += gas[i] - cost[i] if total &amp;lt; 0: start = i + 1 total = 0 return start</description></item><item><title>1029. Two City Scheduling</title><link>https://zalman0813.github.io/posts/two-city-scheduling/</link><pubDate>Sun, 26 Feb 2023 21:56:28 +0800</pubDate><guid>https://zalman0813.github.io/posts/two-city-scheduling/</guid><description>Link: https://leetcode.com/problems/two-city-scheduling/
Solution: greedy
# Time Complexity: O(nlogn) # Space Complexity: O(m + n), m represents the memory required to sort this array. # Python uses a combination of merge sort and insertion sort which can sort the array in O(m) class Solution: def twoCitySchedCost(self, costs: List[List[int]]) -&amp;gt; int: diff = [] for costa, costb in costs: diff.append([costa - costb, costa, costb]) diff.sort() result = 0 tot = len(costs) for i in range(tot): if i &amp;gt;= tot / 2: result += diff[i][2] else: result += diff[i][1] return result</description></item><item><title>45. Jump Game Ii</title><link>https://zalman0813.github.io/posts/jump-game-ii/</link><pubDate>Sun, 26 Feb 2023 21:38:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/jump-game-ii/</guid><description>Link: https://leetcode.com/problems/jump-game-ii/description/
Solution: greedy
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def jump(self, nums: List[int]) -&amp;gt; int: l = r = 0 times = 0 while r &amp;lt; len(nums) - 1: farthest = 0 for i in range(l, r + 1): farthest = max(farthest, i+nums[i]) l = r + 1 r = farthest times += 1 return times</description></item><item><title>81. Search in Rotated Sorted Array Ii</title><link>https://zalman0813.github.io/posts/search-in-rotated-sorted-array-ii/</link><pubDate>Sun, 19 Feb 2023 17:43:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/search-in-rotated-sorted-array-ii/</guid><description>Link: https://leetcode.com/problems/search-in-rotated-sorted-array-ii
Solution: binary search
# Time Complexity: O(log(n)) # Space Complexity: O(1) class Solution: def search(self, nums: List[int], target: int) -&amp;gt; bool: if len(nums) == 1: if nums[0] == target: return True else: return False l, r = 0, len(nums) - 1 while l &amp;lt;= r: # shifting to remove duplicate elements while l&amp;lt;r and nums[l] == nums[l+1]: l+=1 while l&amp;lt;r and nums[r] == nums[r-1]: r-=1 mid = (l + r) // 2 if target == nums[mid]: return True if nums[l] &amp;lt;= nums[mid]: if target &amp;gt;= nums[l] and target &amp;lt; nums[mid]: r = mid - 1 else: l = mid + 1 else: if target &amp;gt; nums[mid] and target &amp;lt;= nums[r]: l = mid + 1 else: r = mid - 1 return False</description></item><item><title>540. Single Element in a Sorted Array</title><link>https://zalman0813.github.io/posts/single-element-in-a-sorted-array/</link><pubDate>Sun, 19 Feb 2023 17:17:20 +0800</pubDate><guid>https://zalman0813.github.io/posts/single-element-in-a-sorted-array/</guid><description>Link: https://leetcode.com/problems/single-element-in-a-sorted-array/
Solution: binary search
# Time Complexity: O(log(n)) # Space Complexity: O(1) class Solution: def singleNonDuplicate(self, nums: List[int]) -&amp;gt; int: l, r = 0, len(nums) - 1 while l &amp;lt; r: m = l + (r-l)//2 # use the pair arrangement propert. even is equalt to next odd until an unpaired number appears, # If the element at mid and mid + 1 are the same then # the single element must appear after the mid point # Otherwise we must search before the mid point if m % 2 == 1: m -= 1 # to preceding even index if nums[m] == nums[m + 1]: l = m + 2 else: r = m return nums[l]</description></item><item><title>528. Random Pick With Weight</title><link>https://zalman0813.github.io/posts/random-pick-with-weight/</link><pubDate>Sun, 19 Feb 2023 17:05:57 +0800</pubDate><guid>https://zalman0813.github.io/posts/random-pick-with-weight/</guid><description>Link: https://leetcode.com/problems/random-pick-with-weight/
Solution: binary search
# Time Complexity: # 1. Construct: O(n) # 2. pickIndex: o(logn) # Space Complexity: # 1. Construct: O(n) # 2. pickIndex: O(1) class Solution: def __init__(self, w: List[int]): self.cum_sums = [] cum = 0 for i in range(len(w)): cum += w[i] self.cum_sums.append(cum) def pickIndex(self) -&amp;gt; int: target = random.randint(1, self.cum_sums[-1]) # Assigning low pointer at the start of the array low = 0 # Assigning high pointer at the end of the array high = len(self.</description></item><item><title>658. Find K Closest Elements</title><link>https://zalman0813.github.io/posts/find-k-closest-elements/</link><pubDate>Sun, 19 Feb 2023 16:44:39 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-closest-elements/</guid><description>Link: https://leetcode.com/problems/find-k-closest-elements/description/
Solution: binary search
# Time Complexity: O(log(n-k)) # Space Complexity: O(1) class Solution: def findClosestElements(self, arr: List[int], k: int, x: int) -&amp;gt; List[int]: l, r = 0, len(arr) - k while l &amp;lt; r: m = l + (r - l) // 2 if x - arr[m] &amp;gt; arr[m+k] - x: l = m + 1 else: r = m return arr[l:l+k]</description></item><item><title>215. Kth Largest Element in an Array</title><link>https://zalman0813.github.io/posts/kth-largest-element-in-an-array/</link><pubDate>Mon, 13 Feb 2023 09:27:14 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-largest-element-in-an-array/</guid><description>Link: https://leetcode.com/problems/kth-largest-element-in-an-array/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(k) import heapq class Solution: def findKthLargest(self, nums: List[int], k: int) -&amp;gt; int: # your code will replace this placeholder return statement minHeap = [] for i in range(len(nums)): if len(minHeap) == k: if minHeap[0] &amp;lt; nums[i]: heappop(minHeap) heappush(minHeap, nums[i]) else: heappush(minHeap, nums[i]) return minHeap[0]</description></item><item><title>347. Top K Frequent Elements</title><link>https://zalman0813.github.io/posts/top-k-frequent-elements/</link><pubDate>Sun, 12 Feb 2023 16:56:14 +0800</pubDate><guid>https://zalman0813.github.io/posts/top-k-frequent-elements/</guid><description>Link: https://leetcode.com/problems/top-k-frequent-elements/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(n+k) from collections import Counter import heapq class Solution: def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]: num_freq = Counter(nums) minHeap = [] for num, count in num_freq.items(): if len(minHeap) == k: if count &amp;gt; minHeap[0][0]: heapq.heappop(minHeap) heapq.heappush(minHeap, (count, num)) else: heapq.heappush(minHeap, (count, num)) return [ num for count, num in minHeap ]</description></item><item><title>973. K Closest Points to Origin</title><link>https://zalman0813.github.io/posts/k-closest-points-to-origin/</link><pubDate>Sun, 12 Feb 2023 16:14:53 +0800</pubDate><guid>https://zalman0813.github.io/posts/k-closest-points-to-origin/</guid><description>Link: https://leetcode.com/problems/k-closest-points-to-origin/description/
Solution: top k elements Code: top k elements
# Time Complexity: O(nlogk) # Space Complexity: O(k) import heapq class Solution: def kClosest(self, points: List[List[int]], K: int) -&amp;gt; List[List[int]]: maxHeap = [] for (x, y) in points: if len(maxHeap) == K: head_x = maxHeap[0][1][0] head_y = maxHeap[0][1][1] if self.distance(x, y) &amp;lt; self.distance(head_x, head_y): heapq.heappop(maxHeap) heapq.heappush(maxHeap, [-self.distance(x, y), (x, y)]) else: heapq.heappush(maxHeap, [-self.distance(x, y), (x, y)]) return [[point[0], point[1]] for dist, point in maxHeap] def distance(self, x, y): return (x*x + y*y)</description></item><item><title>767. Reorganize String</title><link>https://zalman0813.github.io/posts/reorganize-string/</link><pubDate>Sun, 12 Feb 2023 15:16:54 +0800</pubDate><guid>https://zalman0813.github.io/posts/reorganize-string/</guid><description>Link: https://leetcode.com/problems/reorganize-string/
Solution: top k elements
Code:
# Time Complexity: O(nlogc). Due to c bounded by the size of the alphabet, space is O(n). # Space Complexity: O(c). Due to c bounded by the size of the alphabet, space is O(1). from collections import Counter import heapq class Solution: def reorganizeString(self, s: str) -&amp;gt; str: char_counter = Counter(s) most_freq_chars = [] for char, freq in char_counter.items(): heapq.heappush(most_freq_chars, [-freq, char]) result = &amp;#34;&amp;#34; previous = None while len(most_freq_chars) &amp;gt; 0: count, char = heapq.</description></item><item><title>703. Kth Largest Element in a Stream</title><link>https://zalman0813.github.io/posts/kth-largest-element-in-a-stream/</link><pubDate>Sun, 12 Feb 2023 15:12:46 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-largest-element-in-a-stream/</guid><description>Link: https://leetcode.com/problems/kth-largest-element-in-a-stream/description/
Solution: top k elements
Code:
# Time Complexity: # 1. init function - O(nlogn) # 2. add function - O(logk) # Space Complexity: O(n) import heapq class KthLargest: def __init__(self, k: int, nums: List[int]): self.minHeap = nums self.k = k heapq.heapify(self.minHeap) while len(self.minHeap) &amp;gt; self.k: heappop(self.minHeap) def add(self, val: int) -&amp;gt; int: heappush(self.minHeap, val) if len(self.minHeap) &amp;gt; self.k: heappop(self.minHeap) return self.minHeap[0]</description></item><item><title>4. Median of Two Sorted Arrays</title><link>https://zalman0813.github.io/posts/median-of-two-sorted-arrays/</link><pubDate>Sun, 12 Feb 2023 11:16:44 +0800</pubDate><guid>https://zalman0813.github.io/posts/median-of-two-sorted-arrays/</guid><description>Link: https://leetcode.com/problems/median-of-two-sorted-arrays/
Solution: k-ways merge
Code:
# Time Complexity: O(log(min(m,n))) # Space Complexity: O(1) class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float: if len(nums1) &amp;gt; len(nums2): return self.findMedianSortedArrays(nums2, nums1) if len(nums1) == 0: if len(nums2) % 2 == 0: return (nums2[len(nums2)//2 - 1] + nums2[len(nums2)//2])/2 else: return nums2[len(nums2)//2] tot_len = len(nums1) + len(nums2) start, end = 0, len(nums1) while start &amp;lt;= end: cut_1 = (start + end) // 2 cut_2 = (tot_len + 1) // 2 - cut_1 left_1 = float(-inf) if cut_1 == 0 else nums1[cut_1 - 1] right_1 = float(inf) if cut_1 == len(nums1) else nums1[cut_1] left_2 = float(-inf) if cut_2 == 0 else nums2[cut_2 - 1] right_2 = float(inf) if cut_2 == len(nums2) else nums2[cut_2] if left_1 &amp;gt; right_2: end = cut_1 - 1 elif left_2 &amp;gt; right_1: start = cut_1 + 1 else: if tot_len % 2 == 0: return (max(left_1, left_2) + min(right_1, right_2)) / 2 else: return max(left_1, left_2) return -1</description></item><item><title>417. Pacific Atlantic Water Flow</title><link>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</link><pubDate>Sun, 05 Feb 2023 23:33:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/pacific-atlantic-water-flow/</guid><description>Link: https://leetcode.com/problems/pacific-atlantic-water-flow/
Solution: dfs
Code: dfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def pacificAtlantic(self, heights: List[List[int]]) -&amp;gt; List[List[int]]: pac = set() atl = set() ROWS = len(heights) COLS = len(heights[0]) def dfs(r, c, visit, prevHeight): if ((r, c) in visit or r &amp;lt; 0 or c &amp;lt; 0 or r &amp;gt;= ROWS or c &amp;gt;= COLS or heights[r][c] &amp;lt; prevHeight ): return visit.add((r,c)) dfs(r + 1, c, visit, heights[r][c]) dfs(r - 1, c, visit, heights[r][c]) dfs(r, c + 1, visit, heights[r][c]) dfs(r, c - 1, visit, heights[r][c]) for c in range(COLS): dfs(0, c, pac, heights[0][c]) dfs(ROWS - 1, c, atl, heights[ROWS - 1][c]) for r in range(ROWS): dfs(r, 0, pac, heights[r][0]) dfs(r, COLS - 1, atl, heights[r][COLS-1]) res = [] for r in range(ROWS): for c in range(COLS): if (r, c) in pac and (r, c) in atl: res.</description></item><item><title>1730. Shortest Path to Get Food</title><link>https://zalman0813.github.io/posts/shortest-path-to-get-food/</link><pubDate>Sun, 05 Feb 2023 23:28:13 +0800</pubDate><guid>https://zalman0813.github.io/posts/shortest-path-to-get-food/</guid><description>Link: https://leetcode.com/problems/shortest-path-to-get-food/
Solution: bfs
Code: bfs
# Time Complexity: O(m*n) # Space Complexity: O(m*n) class Solution: def getFood(self, grid): ROWS, COLS = len(grid), len(grid[0]) visit, queue = set(), collections.deque() for r in range(ROWS): for c in range(COLS): if grid[r][c] == &amp;#39;*&amp;#39;: queue.append((r,c, 0)) visit.add((r,c)) break directions = [(1,0),(0,-1), (-1,0), (0,1)] while queue: cur_r, cur_c, steps = queue.popleft() if grid[cur_r][cur_c] == &amp;#39;#&amp;#39;: return steps else: for dr,dc in directions: new_r, new_c = r + dr, c + dc if (0&amp;lt;=new_r&amp;lt;ROWS) and (0&amp;lt;=new_c&amp;lt;COLS) and grid[new_r][new_c] !</description></item><item><title>23. Merge K Sorted Lists</title><link>https://zalman0813.github.io/posts/merge-k-sorted-lists/</link><pubDate>Sun, 05 Feb 2023 23:13:17 +0800</pubDate><guid>https://zalman0813.github.io/posts/merge-k-sorted-lists/</guid><description>Link: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(nlogk), where k is the number of lists and n is the max length of a single list # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def merge_2_lists(self, head1, head2): dummy = ListNode(-1) prev = dummy # set prev pointer to dummy node # traverse over the lists until both or one of them becomes null while head1 and head2: if head1.</description></item><item><title>373. Find K Pairs With Smallest Sums</title><link>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</link><pubDate>Sun, 05 Feb 2023 21:28:17 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-k-pairs-with-smallest-sums/</guid><description>Link: https://leetcode.com/problems/find-k-pairs-with-smallest-sums
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(mlogm + klogm) -&amp;gt; (m + k)logm # Space Complexity: O(m), where m = min(k, n1) class Solution: def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -&amp;gt; List[List[int]]: result = [] minHeap = [] # pop &amp;amp; push for i in range(min(k,len(nums1))): heappush(minHeap, (nums1[i]+nums2[0], i, 0)) counter = 1 while counter &amp;lt;= k and minHeap: _, i1, i2 = heappop(minHeap) result.</description></item><item><title>378. Kth Smallest Element in a Sorted Matrix</title><link>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</link><pubDate>Fri, 03 Feb 2023 22:34:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/kth-smallest-element-in-a-sorted-matrix/</guid><description>Link: https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/
Solution: K-way merge
Code: K-way merge
# Time Complexity: O(nlogn+(klogn))=O((n+k)logn) # Space Complexity: O(n*n) class Solution: def kthSmallest(self, matrix: List[List[int]], k: int) -&amp;gt; int: # TODO: Write your code here minHeap = [] # firstly, insert (first elemetn of list, index of fist element, list) for l in matrix: heappush(minHeap, (l[0], 0, l)) for _ in range(k - 1): value, index, l = heappop(minHeap) index += 1 if index &amp;lt; len(l): heappush(minHeap, (l[index], index, l)) value, _, _ = heappop(minHeap) return value</description></item><item><title>30. Substring With Concatenation of All Words</title><link>https://zalman0813.github.io/posts/substring-with-concatenation-of-all-words/</link><pubDate>Sun, 22 Jan 2023 19:31:04 +0800</pubDate><guid>https://zalman0813.github.io/posts/substring-with-concatenation-of-all-words/</guid><description>Link: https://leetcode.com/problems/substring-with-concatenation-of-all-words
Solution: sliding windows
Code:
# O(n∗m∗len) where ‘n’ is the number of characters in the given string, ‘m’ is the total number of words, and ‘len’ is the length of a word. # Space Complexity: O(n+m) class Solution: def findSubstring(self, str1: str, words: List[str]) -&amp;gt; List[int]: result_indices = [] # TODO: Write your code here word_freq = Counter(words) word_count = len(words) word_length = len(words[0]) for i in range((len(str1) - word_count * word_length) + 1): word_seen = {} for j in range(word_count): next_word_index = i + j * word_length # if not equal to the word # Get the next word from the string word = str1[next_word_index: next_word_index + word_length] if word not in word_freq: # Break if we don&amp;#39;t need this word break word_seen[word] = 1 + word_seen.</description></item><item><title>436. Find Right Interval</title><link>https://zalman0813.github.io/posts/find-right-interval/</link><pubDate>Sun, 22 Jan 2023 13:12:57 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-right-interval/</guid><description>Link: https://leetcode.com/problems/find-right-interval/
Solution: two heaps
Code:
# Time Complexity: O(nlogn) # Space Complexity: O(n) class Solution: def findRightInterval(self, intervals: List[List[int]]) -&amp;gt; List[int]: n = len(intervals) # heaps for finding the maximum start and end maxStartHeap, maxEndHeap = [], [] result = [0 for x in range(n)] for endIndex in range(n): heappush(maxStartHeap, (-intervals[endIndex][0], endIndex)) heappush(maxEndHeap, (-intervals[endIndex][1], endIndex)) # go through all the intervals to find each interval&amp;#39;s next interval for _ in range(n): # let&amp;#39;s find the next interval of the interval which has the highest &amp;#39;end&amp;#39; topEnd, endIndex = heappop(maxEndHeap) result[endIndex] = -1 # defaults to - 1 if -maxStartHeap[0][0] &amp;gt;= -topEnd: topStart, startIndex = heappop(maxStartHeap) # find the the interval that has the closest &amp;#39;start&amp;#39; while maxStartHeap and -maxStartHeap[0][0] &amp;gt;= -topEnd: topStart, startIndex = heappop(maxStartHeap) result[endIndex] = startIndex # put the interval back as it could be the next interval of other intervals heappush(maxStartHeap, (topStart, startIndex)) return result</description></item><item><title>6297. Sort the Students by Their Kth Score</title><link>https://zalman0813.github.io/posts/sort-the-students-by-their-kth-score/</link><pubDate>Sun, 22 Jan 2023 11:25:42 +0800</pubDate><guid>https://zalman0813.github.io/posts/sort-the-students-by-their-kth-score/</guid><description>Link: https://leetcode.com/contest/weekly-contest-329/problems/sort-the-students-by-their-kth-score/
Code:
# Time Complexity: O(nlogn) # Space Complexity: O(n) from heapq import * class Solution: def sortTheStudents(self, score: List[List[int]], k: int) -&amp;gt; List[List[int]]: maxHeap = [] for i in range (len(score)): heappush(maxHeap, (-score[i][k], i)) result = [] while maxHeap: student_score, i = heappop(maxHeap) result.append(score[i]) return result</description></item><item><title>6296. Alternating Digit Sum</title><link>https://zalman0813.github.io/posts/alternating-digit-sum/</link><pubDate>Sun, 22 Jan 2023 11:09:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/alternating-digit-sum/</guid><description>Link: https://leetcode.com/contest/weekly-contest-329/problems/alternating-digit-sum/
Code:
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def alternateDigitSum(self, n: int) -&amp;gt; int: sum = 0 digit_num = 0 sign = 1 while n &amp;gt; 0: digit = n % 10 n //= 10 sum += sign*digit digit_num += 1 sign *= -1 return sum if digit_num % 2 == 1 else -sum</description></item><item><title>502. Ipo</title><link>https://zalman0813.github.io/posts/ipo/</link><pubDate>Sat, 21 Jan 2023 16:44:56 +0800</pubDate><guid>https://zalman0813.github.io/posts/ipo/</guid><description>Link: https://leetcode.com/problems/ipo/
Solution: two heaps
Code: two heaps
# Time Complexity: O(nlogn + klogn) , n is the total number of projects, k is the total number of projects we are selecting # Space Complexity: O(n) from heapq import * class Solution: def findMaximizedCapital(self, k: int, w: int, profits: List[int], capital: List[int]) -&amp;gt; int: minCapitalHeap = [] maxProfitHeap = [] # add all projects into minHeap, so that we can select a project with the smallest capital requirement.</description></item><item><title>117. Populating Next Right Pointers in Each Node</title><link>https://zalman0813.github.io/posts/populating-next-right-pointers-in-each-node/</link><pubDate>Sun, 15 Jan 2023 23:38:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/populating-next-right-pointers-in-each-node/</guid><description>Link: https://leetcode.com/problems/populating-next-right-pointers-in-each-node
Solution: BFS Code:
# Time Complexity: O(n) # Space Complexity: O(n) &amp;#34;&amp;#34;&amp;#34; # Definition for a Node. class Node: def __init__(self, val: int = 0, left: &amp;#39;Node&amp;#39; = None, right: &amp;#39;Node&amp;#39; = None, next: &amp;#39;Node&amp;#39; = None): self.val = val self.left = left self.right = right self.next = next &amp;#34;&amp;#34;&amp;#34; class Solution: def connect(self, root: &amp;#39;Optional[Node]&amp;#39;) -&amp;gt; &amp;#39;Optional[Node]&amp;#39;: if not root: return None q = deque() q.append(root) while q: prevNode = None for _ in range(len(q)): curNode = q.</description></item><item><title>437. Path Sum Iii</title><link>https://zalman0813.github.io/posts/path-sum-iii/</link><pubDate>Sun, 15 Jan 2023 23:19:45 +0800</pubDate><guid>https://zalman0813.github.io/posts/path-sum-iii/</guid><description>Link: https://leetcode.com/problems/path-sum-iii/
Solution: DFS Code:
# Time Complexity: O(n) # Space Complexity: O(n) def count_paths(root, S): # TODO: Write your code here m = {} return count_paths_recursive(root, S, m, 0) def count_paths_recursive(curNode, S, cached, curPathSum): if not curNode: return 0 curPathSum += curNode.val path_count = 0 if curPathSum == S: path_count += 1 path_count += cached.get(curPathSum - S, 0) cached[curPathSum] = cached.get(curPathSum, 0) + 1 path_count += count_paths_recursive(curNode.left, S, cached, curPathSum) path_count += count_paths_recursive(curNode.</description></item><item><title>295. Find Median From Data Stream</title><link>https://zalman0813.github.io/posts/find-median-from-data-stream/</link><pubDate>Sun, 15 Jan 2023 19:28:37 +0800</pubDate><guid>https://zalman0813.github.io/posts/find-median-from-data-stream/</guid><description>Link: https://leetcode.com/problems/find-median-from-data-stream
Solution: two heaps Code:
# Time Complexity: # addNume: O(logn) # findMedian: O(1) # Space Complexity: O(n) from heapq import * class MedianFinder: def __init__(self): self.maxHeap = [] self.minHeap = [] def addNum(self, num: int) -&amp;gt; None if not self.maxHeap or -self.maxHeap[0] &amp;gt;= num: heappush(self.maxHeap, -num) else: heappush(self.minHeap, num) # more element than the min-heap # i.e. maxHeap [-5, -3, -1], minHeap [6, 7] if len(self.maxHeap) &amp;gt; len(self.minHeap) + 1: heappush(self.</description></item><item><title>199. Binary Tree Right Side View</title><link>https://zalman0813.github.io/posts/binary-tree-right-side-view/</link><pubDate>Sat, 14 Jan 2023 22:24:32 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-tree-right-side-view/</guid><description>Link: https://leetcode.com/problems/binary-tree-maximum-path-sum
Solution: dfs Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right from collections import deque class Solution: def rightSideView(self, root: Optional[TreeNode]) -&amp;gt; List[int]: if not root: return [] result = [] q = deque() q.append(root) while q: for i in range(len(q)): curNode = q.</description></item><item><title>124. Binary Tree Maximum Path Sum</title><link>https://zalman0813.github.io/posts/binary-tree-maximum-path-sum/</link><pubDate>Sat, 14 Jan 2023 22:10:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-tree-maximum-path-sum/</guid><description>Link: https://leetcode.com/problems/binary-tree-maximum-path-sum
Solution: dfs Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxPathSum(self, root: Optional[TreeNode]) -&amp;gt; int: self.globalPathSum = -math.inf self.pathRecursive(root) return self.maxDiameter def pathRecursive(self, curNode): if not curNode: return 0 maxPathSumFromLeftNode = self.pathRecursive(curNode.left) maxPathSumFromRightNode = self.pathRecursive(curNode.right) # ignore paths with negative sums, since we need to find thhe maximum sum we should # ignore any path which has an overall negative sum.</description></item><item><title>457. Circular Array Loop</title><link>https://zalman0813.github.io/posts/circular-array-loop/</link><pubDate>Sun, 08 Jan 2023 17:27:02 +0800</pubDate><guid>https://zalman0813.github.io/posts/circular-array-loop/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: slow-fast Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def circularArrayLoop(self, arr: List[int]) -&amp;gt; bool: #remember all the numbers that have been visited visited = set() for i in range(len(arr)): if i in visited: continue is_forward = arr[i] &amp;gt;= 0 # if we are moving forward or not slow, fast = i, i # if slow or fast becomes &amp;#39;-1&amp;#39; this means we can&amp;#39;t find cycle for this number while True: # move one step for slow pointer slow = self.</description></item><item><title>61. Rotate List</title><link>https://zalman0813.github.io/posts/rotate-list/</link><pubDate>Sun, 08 Jan 2023 16:44:33 +0800</pubDate><guid>https://zalman0813.github.io/posts/rotate-list/</guid><description>Link: https://leetcode.com/problems/rotate-list
Solution: linked-list
Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def rotateRight(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: if k &amp;lt;= 0 or not head: return head # find last node and length last_node = head list_length = 1 while last_node.next: last_node = last_node.</description></item><item><title>25. Reverse Nodes in K Group</title><link>https://zalman0813.github.io/posts/reverse-nodes-in-k-group/</link><pubDate>Sun, 08 Jan 2023 15:28:49 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-nodes-in-k-group/</guid><description>Link: https://leetcode.com/problems/reverse-nodes-in-k-group
Solution: linked-list
Code: in-place reverse
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -&amp;gt; Optional[ListNode]: if k &amp;lt;= 1 or head is None: return head prev, cur = None, head while cur: last_node_of_last_part, last_node_of_cur_group = prev, cur #check if rest of nodes is less than k.</description></item><item><title>92. Reverse Linked List Ii</title><link>https://zalman0813.github.io/posts/reverse-linked-list-ii/</link><pubDate>Sun, 08 Jan 2023 14:29:47 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-linked-list-ii/</guid><description>Link: https://leetcode.com/problems/reverse-linked-list-ii
Solution: in-place reversal of a linkedlist
Code:
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&amp;gt; Optional[ListNode]: if left == right: return head # after skipping &amp;#39;left-1&amp;#39; nodes, current will point to &amp;#39;left&amp;#39;th node prev, cur = None, head i = 0 while cur and i &amp;lt; left - 1: prev, cur = cur, cur.</description></item><item><title>42. First Missing Positive</title><link>https://zalman0813.github.io/posts/first-missing-positive/</link><pubDate>Sat, 07 Jan 2023 21:57:48 +0800</pubDate><guid>https://zalman0813.github.io/posts/first-missing-positive/</guid><description>Link: https://leetcode.com/problems/first-missing-positive
Solution: cyclic sort
Code:
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def firstMissingPositive(self, nums: List[int]) -&amp;gt; int: i = 0 n = len(nums) while i &amp;lt; n: j = nums[i] - 1 if nums[i] &amp;gt; 0 and nums[i] &amp;lt;= n and nums[i] != nums[j]: nums[i], nums[j] = nums[j], nums[i] else: i += 1 for i in range(n): if nums[i] != i + 1: return i + 1 # if missing number is over n, it&amp;#39;s as n + 1 return n + 1</description></item><item><title>2515. Shortest Distance to Target String in a Circular Array</title><link>https://zalman0813.github.io/posts/shortest-distance-to-target-string-in-a-circular-array/</link><pubDate>Sun, 25 Dec 2022 21:53:07 +0800</pubDate><guid>https://zalman0813.github.io/posts/shortest-distance-to-target-string-in-a-circular-array/</guid><description>Link: https://leetcode.com/contest/weekly-contest-325/problems/shortest-distance-to-target-string-in-a-circular-array/
Status: done
Solution: two pointers
Code: Time Complexity: O(n)
Space Complexity: O(1)
class Solution: def closetTarget(self, words: List[str], target: str, startIndex: int) -&amp;gt; int: if words[startIndex] == target: return 0 n = len(words) i = (startIndex + 1) % n step = 1 min_step = n while i != startIndex: if words[i] == target: min_step = min( step , min_step ) step += 1 i = (i + 1) % n step = 1 i = (startIndex - 1 + n) % n while i !</description></item><item><title>75. Sort Colors</title><link>https://zalman0813.github.io/posts/sort-colors/</link><pubDate>Sun, 25 Dec 2022 21:47:51 +0800</pubDate><guid>https://zalman0813.github.io/posts/sort-colors/</guid><description>Link: https://leetcode.com/problems/sort-colors
Status: done
Solution: two pointers
Code: Time Complexity: O(n)
Space Complexity: O(1)
class Solution: def sortColors(self, arr: List[int]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify nums in-place instead. &amp;#34;&amp;#34;&amp;#34; low = 0 high = len(arr) - 1 i = 0 while i &amp;lt;= high: if arr[i] == 0: arr[i], arr[low] = arr[low], arr[i] low += 1 i += 1 elif arr[i] == 2: arr[i], arr[high] = arr[high], arr[i] high -= 1 else: i += 1 return arr</description></item><item><title>18. 4sum</title><link>https://zalman0813.github.io/posts/4sum/</link><pubDate>Sun, 25 Dec 2022 21:42:19 +0800</pubDate><guid>https://zalman0813.github.io/posts/4sum/</guid><description>Link: https://leetcode.com/problems/4sum
Status: done
Solution: two pointers
Code: Time Complexity: O(nlogn) + O(n^3) =&amp;gt; O(n)
Space Complexity: O(n)
class Solution: def fourSum(self, arr: List[int], target: int) -&amp;gt; List[List[int]]: quadruplets = [] # TODO: Write your code here arr.sort() for i in range(0, len(arr) - 3): if i &amp;gt; 0 and arr[i] == arr[i - 1]: continue for j in range(i + 1, len(arr) - 2): if j &amp;gt; i + 1 and arr[j] == arr[j - 1]: continue left = j + 1 right = len(arr) - 1 while left &amp;lt; right: target_sum = target - arr[i] - arr[j] - arr[left] - arr[right] if target_sum == 0: quadruplets.</description></item><item><title>844. Backspace String Compare</title><link>https://zalman0813.github.io/posts/backspace-string-compare/</link><pubDate>Sun, 25 Dec 2022 21:18:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/backspace-string-compare/</guid><description>Link: https://leetcode.com/problems/backspace-string-compare/
Status: done
Solution: two pointers
Code: Time Complexity: O(n + m)
Space Complexity: O(1)
class Solution: def get_next_valid_char_index(self, str, index): backspace_count = 0 while (index &amp;gt;= 0): if str[index] == &amp;#39;#&amp;#39;: # found a backspace character backspace_count += 1 elif backspace_count &amp;gt; 0: # a non-backspace character backspace_count -= 1 else: break index -= 1 # skip a backspace or a valid character return index def backspaceCompare(self, s: str, t: str) -&amp;gt; bool: s_index = len(s) - 1 t_index = len(t) - 1 while s_index &amp;gt;= 0 or t_index &amp;gt;= 0: s_index = self.</description></item><item><title>252. Meeting Rooms</title><link>https://zalman0813.github.io/posts/meeting-rooms/</link><pubDate>Mon, 19 Dec 2022 23:38:29 +0800</pubDate><guid>https://zalman0813.github.io/posts/meeting-rooms/</guid><description>Link: https://leetcode.com/problems/meeting-rooms/
Status: done
Solution: interval
Code:
class Solution: def meetingRooms(self, intervals: List[int]) -&amp;gt; bool: intervals.sort(lambda x: x.start) for i in range(1, len(intervals)): i1 = intervals[i - 1] i2 = intervals[i] if i1.end &amp;gt; i2.start: return False return True</description></item><item><title>217. Contains Duplicate</title><link>https://zalman0813.github.io/posts/contains-duplicate/</link><pubDate>Fri, 09 Dec 2022 19:28:08 +0800</pubDate><guid>https://zalman0813.github.io/posts/contains-duplicate/</guid><description>Solution: hashmap
Code:
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: count = {} for n in nums: if n in count: return True else: count[n] = 1 return False # Time Complexity: O(n) # Space Complexity: O(n) class Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: return len(set(nums)) != len(nums)</description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://zalman0813.github.io/posts/maximum-depth-of-binary-tree/</link><pubDate>Thu, 08 Dec 2022 22:32:48 +0800</pubDate><guid>https://zalman0813.github.io/posts/maximum-depth-of-binary-tree/</guid><description>Link: https://leetcode.com/problems/maximum-depth-of-binary-tree
Status: done
Solution: dfs
Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: Optional[TreeNode]) -&amp;gt; int: return self.get_depth(root) def get_depth(self, root): if not root: return 0 left_depth = self.get_depth(root.left) right_depth = self.get_depth(root.right) return 1 + max(left_depth, right_depth)</description></item><item><title>876. Middle of the Linked List</title><link>https://zalman0813.github.io/posts/middle-of-the-linked-list/</link><pubDate>Wed, 07 Dec 2022 22:27:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/middle-of-the-linked-list/</guid><description>Link: https://leetcode.com/problems/middle-of-the-linked-list/
Status: done
Solution: two pointer
Code:
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def middleNode(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: low = fast = head while fast and fast.next: low = low.next fast = fast.next.next return low</description></item><item><title>543. Diameter of Binary Tree</title><link>https://zalman0813.github.io/posts/diameter-of-binary-tree/</link><pubDate>Wed, 07 Dec 2022 00:00:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/diameter-of-binary-tree/</guid><description>Link: https://leetcode.com/problems/diameter-of-binary-tre
Solution: dfs
Code:
# Time Complexity: O(n) # Space Complexity: O(n) # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&amp;gt; int: self.max_diameter = 0 self.getDiameter(root) return self.max_diameter def getDiameter(self, root): if not root: return 0 left_depth = self.getDiameter(root.left) right_depth = self.getDiameter(root.right) # get the diameter between two nodes diameter = left_depth + right_depth # get the maximum diameter self.</description></item><item><title>67. Add Binary</title><link>https://zalman0813.github.io/posts/add-binary/</link><pubDate>Fri, 25 Nov 2022 17:43:17 +0800</pubDate><guid>https://zalman0813.github.io/posts/add-binary/</guid><description>Link: https://leetcode.com/problems/add-binary/
Code:
# Time Complexity: O(n) or n(m), n - a.length, m - b.length # Space Complexity: O(n+m) class Solution: def addBinary(self, a: str, b: str) -&amp;gt; str: res = &amp;#39;&amp;#39; carry = 0 a = list(a) b = list(b) while a or b or carry: if a: carry += int(a.pop()) if b: carry += int(b.pop()) res += str(carry % 2) carry = carry // 2 return res[::-1]</description></item><item><title>169. Majority Element</title><link>https://zalman0813.github.io/posts/majority-element/</link><pubDate>Thu, 24 Nov 2022 19:39:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/majority-element/</guid><description>Link: https://leetcode.com/problems/majority-element/
Status: done
Solution: sorted, counting
Code:
sorted # Time Complexity: O(nlogn) # Space Complexity: O(1) class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: nums.sort() # majority element that appears more than ⌊n / 2⌋ times, so mid will be the majority element. mid = len(nums) // 2 return nums[mid] counting # Time Complexity: O(n) # Space Complexity: O(1) class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: res, counts = 0, 0 for n in nums: # When counts == 0, we initate res.</description></item><item><title>206. Reverse Linked List</title><link>https://zalman0813.github.io/posts/reverse-linked-list/</link><pubDate>Wed, 23 Nov 2022 23:58:22 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-linked-list/</guid><description>Link: https://leetcode.com/problems/reverse-linked-list/
Solution: linked-list
Code: linked-list
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, cur = None, head while cur: tmp = cur.next cur.next = prev prev = cur cur = tmp return prev</description></item><item><title>409. Longest Palindrome</title><link>https://zalman0813.github.io/posts/longest-palindrome/</link><pubDate>Tue, 22 Nov 2022 23:12:44 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-palindrome/</guid><description>Link: https://leetcode.com/problems/longest-palindrome/
Solution: hashmap
Code:
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def longestPalindrome(self, s: str) -&amp;gt; int: if len(s) == 1: return 1 char_freq = collections.Counter(s) length = 0 for count in char_freq.values(): # add max even count of all chars length += count // 2 * 2 # if string includes odd char,length + 1 [can choose only one odd count] # if total chars are event counts, return original string length return min(length + 1, len(s))</description></item><item><title>70. Climing Stairs</title><link>https://zalman0813.github.io/posts/climing-stairs/</link><pubDate>Mon, 21 Nov 2022 22:14:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/climing-stairs/</guid><description>Solution: dp - top down
Code:
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: # DP: top-down # due to one step and two steps, # (n-2)th result depends on the result of n - 1, n # case n = 3, it&amp;#39;s two way here, # two step: 1 -&amp;gt; -&amp;gt; 3 # one step: 1 -&amp;gt; 2 # initiate one step, two step as 1.</description></item><item><title>383. Ransom Note</title><link>https://zalman0813.github.io/posts/ransom-note/</link><pubDate>Fri, 18 Nov 2022 21:11:51 +0800</pubDate><guid>https://zalman0813.github.io/posts/ransom-note/</guid><description>Link: https://leetcode.com/problems/ransom-note/
Status: done
Solution: hashmap
Code:
# n - magazine size ,m - ransomNote size # Time Complexity: O(n + m) -&amp;gt; O(n), if true, n &amp;gt;= m # Space Complexity: O(n) class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&amp;gt; bool: if len(ransomNote) &amp;gt; len(magazine): return False mMap = {} for c in magazine: mMap[c] = 1 + mMap.get(c, 0) for char in ransomNote: if char in mMap and mMap[char] &amp;gt; 0: mMap[char] -= 1 else: return False return True</description></item><item><title>278. First Bad Version</title><link>https://zalman0813.github.io/posts/first-bad-version/</link><pubDate>Thu, 17 Nov 2022 20:49:28 +0800</pubDate><guid>https://zalman0813.github.io/posts/first-bad-version/</guid><description>Link: https://leetcode.com/problems/first-bad-version/
Solution: binary search
Code:
class Solution: def firstBadVersion(self, n: int) -&amp;gt; int: l, r = 1, n # Find whether the mid version is bad or not # keep r as m is True, # F, F, T ,T , T # l-&amp;gt; m r # l r # l-&amp;gt; # l from false to true, so final l position as minBadVersion while l &amp;lt; r: m = l + (r-l) // 2 # avoid overflow if isBadVersion(m): r = m else: l = m + 1 return l Time Complexity: O(logn)</description></item><item><title>232. Implement Queue using Stacks</title><link>https://zalman0813.github.io/posts/implement-queue-using-stacks/</link><pubDate>Wed, 16 Nov 2022 23:32:10 +0800</pubDate><guid>https://zalman0813.github.io/posts/implement-queue-using-stacks/</guid><description>Link: https://leetcode.com/problems/implement-queue-using-stacks/
Solution: stack
Code: two stack
# Time Complexity: O(1) # Space Complexity: O(n) class MyQueue: def __init__(self): self.inStack = [] self.outStack = [] def push(self, x: int) -&amp;gt; None: self.inStack.append(x) return self def pop(self) -&amp;gt; int: self.move() return self.outStack.pop() def peek(self) -&amp;gt; int: self.move() return self.outStack[-1] def empty(self) -&amp;gt; bool: return (not self.inStack) and (not self.outStack) def move(self): if not self.outStack: while self.inStack: self.outStack.append(self.inStack.pop())</description></item><item><title>141. Linked List Cycle</title><link>https://zalman0813.github.io/posts/linked-list-cycle/</link><pubDate>Tue, 15 Nov 2022 22:16:09 +0800</pubDate><guid>https://zalman0813.github.io/posts/linked-list-cycle/</guid><description>Link: https://leetcode.com/problems/linked-list-cycle/
Status: done
Solution: Fast &amp;amp; Slow Pointer
Code:
class Solution: def hasCycle(self, head: Optional[ListNode]) -&amp;gt; bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False Time Complexity: O(n)
Space Complexity: O(1)</description></item><item><title>Balanced Binary Tree</title><link>https://zalman0813.github.io/posts/balanced-binary-tree/</link><pubDate>Mon, 14 Nov 2022 19:06:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/balanced-binary-tree/</guid><description>Solution: dfs
Code:
def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool: # use dfs to dive and conquer to find [balanced, height] for each child node. def dfs(root): if not root: return [True, 0] left, right = dfs(root.left), dfs(root.right) balanced = left[0] and right[0] and abs(left[1] - right[1]) &amp;lt;= 1 return [ balanced, 1 + max(left[1], right[1])] return dfs(root)[0] Time Complexity: O(n)
Space Complexity: O(n)</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</link><pubDate>Fri, 11 Nov 2022 23:20:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</guid><description>Link: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Status: done
Solution: binary search, dfs, recursive
Code:
binary search # Time Complexity: O(LogN) # Space Complexity: O(1) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: cur = root while cur: if cur.val &amp;gt; p.val and cur.val &amp;gt; q.val: cur = cur.left elif cur.val &amp;lt; p.val and cur.val &amp;lt; q.val: cur = cur.right else: return cur dfs - without binary search info - &amp;ldquo;236. Lowest Common Ancestor of a Binary Tree&amp;rdquo; # Time Complexity: O(LogN) # Space Complexity: O(LogN) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if root == p or root == q or not root: return root left = self.</description></item><item><title>733. Flood Fill</title><link>https://zalman0813.github.io/posts/flood-fill/</link><pubDate>Thu, 10 Nov 2022 20:42:59 +0800</pubDate><guid>https://zalman0813.github.io/posts/flood-fill/</guid><description>Link: https://leetcode.com/problems/flood-fill/
Solution: dfs
Code:
class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -&amp;gt; List[List[int]]: if image[sr][sc] == color: return image # keep original color to compare later orgColor = image[sr][sc] self.fill(image, sr, sc, orgColor, color) return image def fill(self, image, sr, sc, orgColor, color): # 1. skip if over matrix range # 2. skip if the color is not the same if ( sr &amp;lt; 0 or sc &amp;lt; 0 or sr &amp;gt;= len(image) or sc &amp;gt;= len(image[0]) or image[sr][sc] !</description></item><item><title>704. Binary Search</title><link>https://zalman0813.github.io/posts/binary-search/</link><pubDate>Wed, 09 Nov 2022 21:19:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-search/</guid><description>Solution: two pointer
Code:
class Solution: class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: if len(nums) == 1: return 0 if nums[0] == target else -1 l = 0 r = len(nums) - 1 while l &amp;lt;= r: mid = (l + r) // 2 if nums[mid] &amp;gt; target: r = mid -1 elif nums[mid] &amp;lt; target: l = mid + 1 else: return mid return -1 Time Complexity: O(logn) Space Complexity: O(1)</description></item><item><title>Valid Anagram</title><link>https://zalman0813.github.io/posts/valid-anagram/</link><pubDate>Tue, 08 Nov 2022 23:12:06 +0800</pubDate><guid>https://zalman0813.github.io/posts/valid-anagram/</guid><description>Solution: hashmap
Code:
class Solution: def isAnagram(self, s: str, t: str) -&amp;gt; bool: return Counter(s) == Counter(t) Time Complexity: O(n) Space Complexity: O(n)
Link: https://leetcode.com/problems/valid-anagram/</description></item><item><title>Invert Binary Tree</title><link>https://zalman0813.github.io/posts/invert-binary-tree/</link><pubDate>Mon, 07 Nov 2022 22:48:58 +0800</pubDate><guid>https://zalman0813.github.io/posts/invert-binary-tree/</guid><description>Link: https://leetcode.com/problems/invert-binary-tree/
Solution: dfs
Code:
class Solution: def invertTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root Time Complexity: O(n)
Space Complexity: O(n)</description></item><item><title>Valid Palindrome</title><link>https://zalman0813.github.io/posts/valid-palindrome/</link><pubDate>Fri, 04 Nov 2022 21:07:32 +0800</pubDate><guid>https://zalman0813.github.io/posts/valid-palindrome/</guid><description>Solution: Two Pointer
Code:
class Solution: def isPalindrome(self, s: str) -&amp;gt; bool: l, r = 0, len(s) - 1 while l &amp;lt; r: while l &amp;lt; r and not self.alphaNum(s[l]): l += 1 while l &amp;lt; r and not self.alphaNum(s[r]): r-=1 if s[l].lower() != s[r].lower(): return False l, r = l+1, r-1 return True def alphaNum(self, c): return (ord(&amp;#39;A&amp;#39;) &amp;lt;= ord(c) &amp;lt;= ord(&amp;#39;Z&amp;#39;) or ord(&amp;#39;a&amp;#39;) &amp;lt;= ord(c) &amp;lt;= ord(&amp;#39;z&amp;#39;) or ord(&amp;#39;0&amp;#39;) &amp;lt;= ord(c) &amp;lt;= ord(&amp;#39;9&amp;#39;) ) Time Complexity: O(n)</description></item><item><title>Best Time to Buy and Sell Stock</title><link>https://zalman0813.github.io/posts/best-time-to-buy-and-sell-stock/</link><pubDate>Thu, 03 Nov 2022 18:48:37 +0800</pubDate><guid>https://zalman0813.github.io/posts/best-time-to-buy-and-sell-stock/</guid><description>Solution: two pointer
Code:
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: maxP = 0 l, r = 0, 1 while r &amp;lt; len(prices): profit = prices[r] - prices[l] if profit &amp;gt; 0: maxP = max(profit, maxP) else: l = r r += 1 return maxP Time Complexity: O(n)
Space Complexity: O(1)</description></item><item><title>Merge Two Sorted Lists</title><link>https://zalman0813.github.io/posts/merge-two-sorted-lists/</link><pubDate>Wed, 02 Nov 2022 22:05:02 +0800</pubDate><guid>https://zalman0813.github.io/posts/merge-two-sorted-lists/</guid><description>Link: https://leetcode.com/problems/merge-two-sorted-lists/
Status: done
Solution: two pointer
Code:
class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode() tail = dummy while list1 and list2: if list1.val &amp;gt; list2.val: tail.next = list2 list2 = list2.next else: tail.next = list1 list1 = list1.next tail = tail.next if list1: tail.next = list1 if list2: tail.next = list2 return dummy.next Time Complexity: O(n)
Space Complexity: O(1)</description></item><item><title>20. Valid Parenthess</title><link>https://zalman0813.github.io/posts/valid-parenthess/</link><pubDate>Tue, 01 Nov 2022 21:38:19 +0800</pubDate><guid>https://zalman0813.github.io/posts/valid-parenthess/</guid><description>Link: https://leetcode.com/problems/valid-parentheses/
Tags: 169, easy, stack
Status: Done
Solution: Stack
Code:
class Solution: def isValid(self, s: str) -&amp;gt; bool: stack = [] Map = {&amp;#34;)&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;]&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;}&amp;#34;: &amp;#34;{&amp;#34;} for char in s: if char in Map: if stack and stack[-1] == Map[char]: stack.pop() else: return False else: stack.append(char) return True if not stack else False Time Complexity: O(n)
Space Complexity:O(n)</description></item><item><title>1.two Sum</title><link>https://zalman0813.github.io/posts/two-sum/</link><pubDate>Mon, 31 Oct 2022 22:01:45 +0800</pubDate><guid>https://zalman0813.github.io/posts/two-sum/</guid><description>Solution: HashMap, Two Pointer
Note:
hashmap: dictionay to store key as num, value as index. tow pointer: sorted and find original index. Need to consider the same value Code:
hashmap class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashMap = {} for i, num in enumerate(nums): rest = target - num if rest in hashMap: return [i, hashMap[rest] ] hashMap[num] = i Time Complexity: O(n) Space Complexity: O(n)</description></item><item><title>First Page</title><link>https://zalman0813.github.io/posts/first-page/</link><pubDate>Thu, 01 Sep 2022 23:45:30 +0800</pubDate><guid>https://zalman0813.github.io/posts/first-page/</guid><description>print(&amp;#34;Hello World&amp;#34;)</description></item><item><title>歷年文章</title><link>https://zalman0813.github.io/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zalman0813.github.io/archives/</guid><description>歷年文章</description></item></channel></rss>