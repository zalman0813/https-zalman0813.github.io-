<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Pin Code Blog</title><link>https://zalman0813.github.io/posts/</link><description>Recent content in Posts on Pin Code Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 24 Nov 2022 19:39:00 +0800</lastBuildDate><atom:link href="https://zalman0813.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>169. Majority Element</title><link>https://zalman0813.github.io/posts/majority-element/</link><pubDate>Thu, 24 Nov 2022 19:39:00 +0800</pubDate><guid>https://zalman0813.github.io/posts/majority-element/</guid><description>Link: https://leetcode.com/problems/majority-element/
Status: done
Solution: sorted, counting
Code:
sorted # Time Complexity: O(nlogn) # Space Complexity: O(1) class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: nums.sort(reverse=True) # majority element that appears more than ⌊n / 2⌋ times, so mid will be the majority element. mid = len(nums) // 2 return nums[mid] counting # Time Complexity: O(n) # Space Complexity: O(1) class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: res, counts = 0, 0 for n in nums: # When counts == 0, we initate res.</description></item><item><title>206. Reverse Linked List</title><link>https://zalman0813.github.io/posts/reverse-linked-list/</link><pubDate>Wed, 23 Nov 2022 23:58:22 +0800</pubDate><guid>https://zalman0813.github.io/posts/reverse-linked-list/</guid><description>Link: https://leetcode.com/problems/reverse-linked-list/
Solution: linked-list
Code: linked-list
# Time Complexity: O(n) # Space Complexity: O(1) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: Optional[ListNode]) -&amp;gt; Optional[ListNode]: prev, cur = None, head while cur: tmp = cur.next cur.next = prev prev = cur cur = tmp return prev</description></item><item><title>409. Longest Palindrome</title><link>https://zalman0813.github.io/posts/longest-palindrome/</link><pubDate>Tue, 22 Nov 2022 23:12:44 +0800</pubDate><guid>https://zalman0813.github.io/posts/longest-palindrome/</guid><description>Link: https://leetcode.com/problems/longest-palindrome/
Solution: hashmap
Code:
# Time Complexity: O(n) # Space Complexity: O(n) class Solution: def longestPalindrome(self, s: str) -&amp;gt; int: if len(s) == 1: return 1 char_freq = collections.Counter(s) length = 0 for count in char_freq.values(): # add max even count of all chars length += count // 2 * 2 # if string includes odd char,length + 1 [can choose only one odd count] # if total chars are event counts, return original string length return min(length + 1, len(s))</description></item><item><title>70. Climing Stairs</title><link>https://zalman0813.github.io/posts/climing-stairs/</link><pubDate>Mon, 21 Nov 2022 22:14:36 +0800</pubDate><guid>https://zalman0813.github.io/posts/climing-stairs/</guid><description>Solution: dp - top down
Code:
# Time Complexity: O(n) # Space Complexity: O(1) class Solution: def climbStairs(self, n: int) -&amp;gt; int: # DP: top-down # due to one step and two steps, # (n-2)th result depends on the result of n - 1, n # case n = 3, it&amp;#39;s two way here, # two step: 1 -&amp;gt; -&amp;gt; 3 # one step: 1 -&amp;gt; 2 # initiate one step, two step as 1.</description></item><item><title>383. Ransom Note</title><link>https://zalman0813.github.io/posts/ransom-note/</link><pubDate>Fri, 18 Nov 2022 21:11:51 +0800</pubDate><guid>https://zalman0813.github.io/posts/ransom-note/</guid><description>Link: https://leetcode.com/problems/ransom-note/
Status: done
Solution: hashmap
Code:
# n - magazine size ,m - ransomNote size # Time Complexity: O(n + m) -&amp;gt; O(n), if true, n &amp;gt;= m # Space Complexity: O(n) class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&amp;gt; bool: if len(ransomNote) &amp;gt; len(magazine): return False mMap = {} for c in magazine: mMap[c] = 1 + mMap.get(c, 0) for char in ransomNote: if char in mMap and mMap[char] &amp;gt; 0: mMap[char] -= 1 else: return False return True</description></item><item><title>278. First Bad Version</title><link>https://zalman0813.github.io/posts/first-bad-version/</link><pubDate>Thu, 17 Nov 2022 20:49:28 +0800</pubDate><guid>https://zalman0813.github.io/posts/first-bad-version/</guid><description>Link: https://leetcode.com/problems/first-bad-version/
Solution: binary search
Code:
class Solution: def firstBadVersion(self, n: int) -&amp;gt; int: l, r = 1, n # Find whether the mid version is bad or not # keep r as m is True, # F, F, T ,T , T # l-&amp;gt; m r # l r # l-&amp;gt; # l from false to true, so final l position as minBadVersion while l &amp;lt; r: m = l + (r-l) // 2 # avoid overflow if isBadVersion(m): r = m else: l = m + 1 return l Time Complexity: O(logn)</description></item><item><title>232. Implement Queue using Stacks</title><link>https://zalman0813.github.io/posts/implement-queue-using-stacks/</link><pubDate>Wed, 16 Nov 2022 23:32:10 +0800</pubDate><guid>https://zalman0813.github.io/posts/implement-queue-using-stacks/</guid><description>Link: https://leetcode.com/problems/implement-queue-using-stacks/
Solution: stack
Code: two stack
# Time Complexity: O(1) # Space Complexity: O(n) class MyQueue: def __init__(self): self.inStack = [] self.outStack = [] def push(self, x: int) -&amp;gt; None: self.inStack.append(x) return self def pop(self) -&amp;gt; int: self.move() return self.outStack.pop() def peek(self) -&amp;gt; int: self.move() return self.outStack[-1] def empty(self) -&amp;gt; bool: return (not self.inStack) and (not self.outStack) def move(self): if not self.outStack: while self.inStack: self.outStack.append(self.inStack.pop())</description></item><item><title>141. Linked List Cycle</title><link>https://zalman0813.github.io/posts/linked-list-cycle/</link><pubDate>Tue, 15 Nov 2022 22:16:09 +0800</pubDate><guid>https://zalman0813.github.io/posts/linked-list-cycle/</guid><description>Link: https://leetcode.com/problems/linked-list-cycle/
Status: done
Solution: Fast &amp;amp; Slow Pointer
Code:
class Solution: def hasCycle(self, head: Optional[ListNode]) -&amp;gt; bool: slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False Time Complexity: O(n)
Space Complexity: O(1)</description></item><item><title>Balanced Binary Tree</title><link>https://zalman0813.github.io/posts/balanced-binary-tree/</link><pubDate>Mon, 14 Nov 2022 19:06:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/balanced-binary-tree/</guid><description>Solution: dfs
Code:
def isBalanced(self, root: Optional[TreeNode]) -&amp;gt; bool: # use dfs to dive and conquer to find [balanced, height] for each child node. def dfs(root): if not root: return [True, 0] left, right = dfs(root.left), dfs(root.right) balanced = left[0] and right[0] and abs(left[1] - right[1]) &amp;lt;= 1 return [ balanced, 1 + max(left[1], right[1])] return dfs(root)[0] Time Complexity: O(n)
Space Complexity: O(n)</description></item><item><title>235. Lowest Common Ancestor of a Binary Search Tree</title><link>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</link><pubDate>Fri, 11 Nov 2022 23:20:24 +0800</pubDate><guid>https://zalman0813.github.io/posts/lca-of-a-binary-search-tree/</guid><description>Link: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/
Status: done
Solution: binary search, dfs, recursive
Code:
binary search # Time Complexity: O(LogN) # Space Complexity: O(1) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: cur = root while cur: if cur.val &amp;gt; p.val and cur.val &amp;gt; q.val: cur = cur.left elif cur.val &amp;lt; p.val and cur.val &amp;lt; q.val: cur = cur.right else: return cur dfs - without binary search info - &amp;ldquo;236. Lowest Common Ancestor of a Binary Tree&amp;rdquo; # Time Complexity: O(LogN) # Space Complexity: O(LogN) class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if root == p or root == q or not root: return root left = self.</description></item><item><title>733. Flood Fill</title><link>https://zalman0813.github.io/posts/flood-fill/</link><pubDate>Thu, 10 Nov 2022 20:42:59 +0800</pubDate><guid>https://zalman0813.github.io/posts/flood-fill/</guid><description>Link: https://leetcode.com/problems/flood-fill/
Solution: dfs
Code:
class Solution: def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -&amp;gt; List[List[int]]: if image[sr][sc] == color: return image # keep original color to compare later orgColor = image[sr][sc] self.fill(image, sr, sc, orgColor, color) return image def fill(self, image, sr, sc, orgColor, color): # 1. skip if over matrix range # 2. skip if the color is not the same if ( sr &amp;lt; 0 or sc &amp;lt; 0 or sr &amp;gt;= len(image) or sc &amp;gt;= len(image[0]) or image[sr][sc] !</description></item><item><title>704. Binary Search</title><link>https://zalman0813.github.io/posts/binary-search/</link><pubDate>Wed, 09 Nov 2022 21:19:27 +0800</pubDate><guid>https://zalman0813.github.io/posts/binary-search/</guid><description>Solution: two pointer
Code:
class Solution: class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: if len(nums) == 1: return 0 if nums[0] == target else -1 l = 0 r = len(nums) - 1 while l &amp;lt;= r: mid = (l + r) // 2 if nums[mid] &amp;gt; target: r = mid -1 elif nums[mid] &amp;lt; target: l = mid + 1 else: return mid return -1 Time Complexity: O(logn) Space Complexity: O(1)</description></item><item><title>Valid Anagram</title><link>https://zalman0813.github.io/posts/valid-anagram/</link><pubDate>Tue, 08 Nov 2022 23:12:06 +0800</pubDate><guid>https://zalman0813.github.io/posts/valid-anagram/</guid><description>Solution: hashmap
Code:
class Solution: def isAnagram(self, s: str, t: str) -&amp;gt; bool: return Counter(s) == Counter(t) Time Complexity: O(n) Space Complexity: O(n)
Link: https://leetcode.com/problems/valid-anagram/</description></item><item><title>Invert Binary Tree</title><link>https://zalman0813.github.io/posts/invert-binary-tree/</link><pubDate>Mon, 07 Nov 2022 22:48:58 +0800</pubDate><guid>https://zalman0813.github.io/posts/invert-binary-tree/</guid><description>Link: https://leetcode.com/problems/invert-binary-tree/
Solution: dfs
Code:
class Solution: def invertTree(self, root: Optional[TreeNode]) -&amp;gt; Optional[TreeNode]: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root Time Complexity: O(n)
Space Complexity: O(n)</description></item><item><title>Valid Palindrome</title><link>https://zalman0813.github.io/posts/valid-palindrome/</link><pubDate>Fri, 04 Nov 2022 21:07:32 +0800</pubDate><guid>https://zalman0813.github.io/posts/valid-palindrome/</guid><description>Solution: Two Pointer
Code:
class Solution: def isPalindrome(self, s: str) -&amp;gt; bool: l, r = 0, len(s) - 1 while l &amp;lt; r: while l &amp;lt; r and not self.alphaNum(s[l]): l += 1 while l &amp;lt; r and not self.alphaNum(s[r]): r-=1 if s[l].lower() != s[r].lower(): return False l, r = l+1, r-1 return True def alphaNum(self, c): return (ord(&amp;#39;A&amp;#39;) &amp;lt;= ord(c) &amp;lt;= ord(&amp;#39;Z&amp;#39;) or ord(&amp;#39;a&amp;#39;) &amp;lt;= ord(c) &amp;lt;= ord(&amp;#39;z&amp;#39;) or ord(&amp;#39;0&amp;#39;) &amp;lt;= ord(c) &amp;lt;= ord(&amp;#39;9&amp;#39;) ) Time Complexity: O(n)</description></item><item><title>Best Time to Buy and Sell Stock</title><link>https://zalman0813.github.io/posts/best-time-to-buy-and-sell-stock/</link><pubDate>Thu, 03 Nov 2022 18:48:37 +0800</pubDate><guid>https://zalman0813.github.io/posts/best-time-to-buy-and-sell-stock/</guid><description>Solution: two pointer
Code:
class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: maxP = 0 l, r = 0, 1 while r &amp;lt; len(prices): profit = prices[r] - prices[l] if profit &amp;gt; 0: maxP = max(profit, maxP) else: l = r r += 1 return maxP Time Complexity: O(n)
Space Complexity: O(1)</description></item><item><title>Merge Two Sorted Lists</title><link>https://zalman0813.github.io/posts/merge-two-sorted-lists/</link><pubDate>Wed, 02 Nov 2022 22:05:02 +0800</pubDate><guid>https://zalman0813.github.io/posts/merge-two-sorted-lists/</guid><description>Link: https://leetcode.com/problems/merge-two-sorted-lists/
Status: done
Solution: two pointer
Code:
class Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&amp;gt; Optional[ListNode]: dummy = ListNode() tail = dummy while list1 and list2: if list1.val &amp;gt; list2.val: tail.next = list2 list2 = list2.next else: tail.next = list1 list1 = list1.next tail = tail.next if list1: tail.next = list1 if list2: tail.next = list2 return dummy.next Time Complexity: O(n)
Space Complexity: O(1)</description></item><item><title>20. Valid Parenthess</title><link>https://zalman0813.github.io/posts/valid-parenthess/</link><pubDate>Tue, 01 Nov 2022 21:38:19 +0800</pubDate><guid>https://zalman0813.github.io/posts/valid-parenthess/</guid><description>Link: https://leetcode.com/problems/valid-parentheses/
Tags: 169, easy, stack
Status: Done
Solution: Stack
Code:
class Solution: def isValid(self, s: str) -&amp;gt; bool: stack = [] Map = {&amp;#34;)&amp;#34;: &amp;#34;(&amp;#34;, &amp;#34;]&amp;#34;: &amp;#34;[&amp;#34;, &amp;#34;}&amp;#34;: &amp;#34;{&amp;#34;} for char in s: if char in Map: if stack and stack[-1] == Map[char]: stack.pop() else: return False else: stack.append(char) return True if not stack else False Time Complexity: O(n)
Space Complexity:O(n)</description></item><item><title>1.two Sum</title><link>https://zalman0813.github.io/posts/two-sum/</link><pubDate>Mon, 31 Oct 2022 22:01:45 +0800</pubDate><guid>https://zalman0813.github.io/posts/two-sum/</guid><description>Solution: HashMap, Two Pointer
Note:
hashmap: dictionay to store key as num, value as index. tow pointer: sorted and find original index. Need to consider the same value Code:
hashmap class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashMap = {} for i, num in enumerate(nums): rest = target - num if rest in hashMap: return [i, hashMap[rest] ] hashMap[num] = i Time Complexity: O(n) Space Complexity: O(n)</description></item><item><title>First Page</title><link>https://zalman0813.github.io/posts/first-page/</link><pubDate>Thu, 01 Sep 2022 23:45:30 +0800</pubDate><guid>https://zalman0813.github.io/posts/first-page/</guid><description>print(&amp;#34;Hello World&amp;#34;)</description></item><item><title>歷年文章</title><link>https://zalman0813.github.io/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://zalman0813.github.io/archives/</guid><description>歷年文章</description></item></channel></rss>